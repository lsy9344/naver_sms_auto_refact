# Story 3.4: Create `rules.yaml` Configuration

**Status:** Approved

---

## Quick Project Assessment

**Current System Context**
- [x] Legacy rule flows mapped in `original_code/lambda_function.py:120-210, 360-410`.
- [x] Supporting modules: condition evaluators (Story 3.2), action executors (Story 3.3), configuration loader (Story 2.4).
- [x] Integration points: `config/rules.yaml`, schema validation in rule engine core (Story 3.1).
- [x] Existing patterns: YAML-driven rule definitions with comments and metadata (`docs/brownfield-architecture.md:978-1015`).

**Change Scope**
- [x] Build complete `config/rules.yaml` capturing current production behavior plus future-ready toggles.
- [x] Provide schema definition and documentation for rule authors.
- [x] Success = declarative rules produce identical side effects compared to legacy logic (via regression tests).

---

## Story

**As a** product owner (authoring rules),
**I want** a declarative `rules.yaml` that encodes all current automation logic,
**so that** future rule changes require configuration edits rather than code deployments.

---

## Story Context

**Existing System Integration:**
- Integrates with: `Settings.load()` for configuration ingestion (Story 2.4), `RuleEngine` constructor (Story 3.1), condition/action registries (Stories 3.2, 3.3).
- Technology: YAML configuration with structured parameters (no templating in rule definitions; templating handled in SMS action executor).
- Follows pattern: Example structures from architecture doc `docs/brownfield-architecture.md:978-1035`.
- Touch points: `src/config/rules.yaml`, `src/config/rules.schema.json`, `docs/rules/rules-config.md`, regression test harness.

---

## Acceptance Criteria

**Functional Requirements**
1. `config/rules.yaml` defines all current rule flows: New Booking Confirmation, Two-Hour Reminder, Evening Option SMS, with `enabled: true`, descriptive `name`, `description`, and `tags`.
2. Each rule lists conditions and actions using the evaluator/executor identifiers established in Stories 3.2 and 3.3, with parameters matching legacy behavior (e.g., `time_before_booking` with `hours: 2`, `has_option_keyword` referencing option keyword list from config).
3. Additional scaffolding included for future rules (e.g., Slack notification template) but disabled via `enabled: false` and documentation, ensuring zero behavior change until activated.
4. YAML passes schema validation defined in `config/rules.schema.json`; schema includes enums for condition/action types, required parameter fields, and optional metadata (priority, notes).
5. Comments or `metadata:` blocks capture business context (store coverage, message templates) sourced from PRD to aid non-developer editors.

**Integration Requirements**
6. Configuration loader (Story 2.4) successfully loads rules into `Settings.rules`; sample program `scripts/print_rules.py` prints summary for verification.
7. Rule engine comparison harness processes legacy booking fixtures through new rules and confirms identical action sequences (SMS type, DB updates, notifications) recorded in `VALIDATION.md`.
8. Documentation (`docs/rules/rules-config.md`) explains file structure, editing guidelines, and testing workflow for rule authors; includes guidance on enabling/disabling rules and adding new ones safely.

**Quality Requirements**
9. Unit tests validate schema enforcement by attempting to load malformed rule definitions (missing fields, invalid types) and confirming descriptive errors.
10. YAML linting (e.g., `yamllint`, `spectral`) included in CI to guard formatting and schema conformance.
11. Versioning strategy documented: use semantic rule versions or Git tags; change log appended to file header with effective date and author.

---

## Dependency Checkpoints

**Before Starting Story 3.4:**
- [ ] Story 3.1 (Rule Engine Core) is MERGED - verify:
  - RuleEngine class exists at `src/rules/engine.py`
  - `evaluate_rule(rule: RuleConfig, context: Dict) -> bool` method signature documented
  - `execute_rule(rule: RuleConfig, context: Dict) -> List[ActionResult]` method signature documented
  - RuleConfig dataclass structure defined
  
- [ ] Story 3.2 (Condition Evaluators) is MERGED - verify:
  - Condition registry populated with all 8 evaluator types (from Epic 3 table)
  - Each condition's parameter schema documented (e.g., `time_before_booking` expects `hours: int`)
  
- [ ] Story 3.3 (Action Executors) is MERGED - verify:
  - Action registry populated with all 6 executor types (from Epic 3 table)
  - Each action's parameter schema documented (e.g., `send_sms` expects `template: str, store_specific: bool`)
  - Send_sms executor handles SMS templates (confirmation, guide, event)

---

## Dev Notes

### Source Tree Information

**File Locations:**
- Create file: `src/config/rules.yaml` (main rule configuration)
- Create file: `src/config/rules.schema.json` (JSON Schema validation)
- Configuration loader: `src/config/settings.py` (Story 2.4)
- Rule engine: `src/rules/engine.py` (Story 3.1)
- Test fixtures: `tests/fixtures/legacy_bookings.json` (5 representative booking scenarios)
- Test baseline: `tests/fixtures/legacy_expected_actions.json` (expected action sequences)
- Regression test: `tests/integration/test_rules_regression.py`
- Schema validation test: `tests/unit/test_rules_schema.py`
- Evidence: `VALIDATION.md` (regression test results)

### Integration Points

**Settings.load() Method** (`src/config/settings.py:45`)
- Loads rules.yaml from file system
- Validates against rules.schema.json using jsonschema library
- Returns populated `Settings.rules: List[RuleConfig]` attribute
- Raises descriptive ValidationError if schema invalid

**RuleEngine Constructor** (`src/rules/engine.py:20`)
- Accepts `rules_config: List[RuleConfig]` parameter
- Initializes `self.rules = rules_config`
- Pre-populated with condition_evaluators registry from Story 3.2
- Pre-populated with action_executors registry from Story 3.3

**Condition Evaluators** (from Story 3.2):
- Registry keys: `booking_not_in_db`, `time_before_booking`, `flag_not_set`, `current_hour`, `booking_status`, `has_option_keyword`, `store_id_matches`, `date_range`
- All evaluators return bool (True = condition met)
- Parameters passed as YAML dict, validated against evaluator schema

**Action Executors** (from Story 3.3):
- Registry keys: `send_sms`, `create_db_record`, `update_flag`, `send_telegram`, `send_slack`, `log_event`
- All executors return ActionResult with execution status
- Parameters passed as YAML dict, validated against executor schema

### Current Rule Patterns from Legacy Code

**Pattern 1: New Booking Confirmation** (`original_code/lambda_function.py:131-167`)
```
When: New booking detected (not in DynamoDB)
Conditions: booking_not_in_db
Actions: 
  1. create_db_record() - Insert new booking into SMS tracking table
  2. send_sms(template='confirmation') - Send confirmation SMS via SENS API
  3. send_telegram(message='...') - Notify via Telegram
Expected: 1 confirmation SMS per new booking
```

**Pattern 2: Two-Hour Reminder** (`original_code/lambda_function.py:160-175`)
```
When: Booking in next 2 hours AND reminder not yet sent
Conditions:
  - time_before_booking(hours=2) - Now is within 2 hours before booking
  - flag_not_set(flag='remind_sms') - DynamoDB remind_sms flag is false
Actions:
  1. send_sms(template='guide', store_specific=true) - Send guide SMS with store-specific info
  2. update_flag(flag='remind_sms', value=true) - Mark reminder as sent in DynamoDB
Expected: 1 reminder SMS per booking, sent at correct time
```

**Pattern 3: Evening Option SMS** (`original_code/lambda_function.py:176-195`)
```
When: Current time is 20:00 (8 PM) AND customer has option AND option SMS not yet sent
Conditions:
  - current_hour(hour=20) - Current time is 8 PM
  - flag_not_set(flag='option_sms') - DynamoDB option_sms flag is false
  - has_option_keyword(keywords=['네이버', '인스타', '원본']) - Customer selected option with matching keyword
Actions:
  1. send_sms(template='event') - Send event/option SMS via SENS API
  2. update_flag(flag='option_sms', value=true) - Mark option SMS as sent in DynamoDB
Expected: 1 option SMS per booking with matching keywords, sent at 8 PM
```

### Testing Standards

**Framework:** pytest (follows `tests/` directory structure)

**Test Locations:**
- Unit tests for schema validation: `tests/unit/test_rules_schema.py`
- Regression test harness: `tests/integration/test_rules_regression.py`
- Fixtures: `tests/fixtures/legacy_bookings.json`, `tests/fixtures/legacy_expected_actions.json`

**Coverage Requirement:** >90% for rules module (rules.yaml processing, schema validation, regression tests)

**Test Patterns:**
- Schema validation: Load valid rules.yaml ✅ Should parse; Load malformed YAML ❌ Should raise ValidationError with descriptive message
- Regression: For each booking fixture → Process through new rule engine → Compare action sequence against baseline → Assert 100% match
- Integration: Load rules.yaml → Initialize RuleEngine → Process sample booking → Verify expected actions executed

### Schema Validation Strategy

**Format:** JSON Schema (draft-07)

**Validation Library:** jsonschema (Python)

**Timing:** Validation occurs in `Settings.load()` on startup
  - File loads as YAML, converted to Python dict
  - jsonschema validates dict against rules.schema.json
  - Descriptive error messages logged to CloudWatch
  - Process fails if schema invalid (prevents bad rules deployment)

**CI Integration:**
- Pre-commit hook: yamllint for YAML formatting (no trailing spaces, proper indentation)
- CI pipeline step: spectral for schema validation against rules.schema.json
- Both must pass before merge to main

---

## Technical Notes

- **Integration Approach:** YAML consumed by configuration loader (Story 2.4), converted to `RuleConfig` dataclasses by rule engine core (Story 3.1).
- **Existing Pattern Reference:** Mapping table in Epic 3 and architecture doc lines 394-465 for condition/action equivalence.
- **Key Constraints:** No behavior changes allowed; ensure keyword lists, store IDs align with configuration files from Epic 2.

---

## Tasks / Subtasks

**Task 1: Create rules.yaml Structure** (AC: 1, 2, 3, 4)
- [ ] Define YAML schema with root `rules:` array containing rule objects
- [ ] Define rule object structure: `name`, `enabled`, `description`, `tags`, `conditions`, `actions`
- [ ] Implement New Booking Confirmation rule with conditions and actions
- [ ] Implement Two-Hour Reminder rule with AND logic for multiple conditions
- [ ] Implement Evening Option SMS rule with all 3 conditions
- [ ] Add disabled template rules for future enhancements (Slack notification, date-range rule)
- [ ] Ensure YAML passes schema validation against rules.schema.json
- [ ] Add header comments explaining file structure and versioning

**Task 2: Create rules.schema.json** (AC: 4, 10)
- [ ] Define JSON Schema (draft-07) for complete rules.yaml structure
- [ ] Define top-level schema: `rules` is array of rule objects
- [ ] Define rule object schema with required fields: `name`, `enabled`, `description`, `conditions`, `actions`
- [ ] Define enums for condition types: booking_not_in_db, time_before_booking, flag_not_set, current_hour, booking_status, has_option_keyword, store_id_matches, date_range
- [ ] Define enums for action types: send_sms, create_db_record, update_flag, send_telegram, send_slack, log_event
- [ ] Define parameter schema for each condition type (e.g., time_before_booking requires `hours: integer`)
- [ ] Define parameter schema for each action type (e.g., send_sms requires `template: string` in enum(confirmation|guide|event))
- [ ] Include optional metadata fields: `tags`, `priority`, `notes`, `effective_date`
- [ ] Verify schema is valid JSON Schema (test with jsonschema validator)

**Task 3: Integrate with Configuration Loader** (AC: 6)
- [ ] Update `src/config/settings.py` to load rules.yaml in Settings class
- [ ] Implement Settings.load() method to:
  - Read rules.yaml from file system
  - Parse YAML into Python dict
  - Validate dict against rules.schema.json using jsonschema
  - Convert validated dict to List[RuleConfig] dataclass objects
  - Set Settings.rules attribute
  - Raise descriptive ValidationError if schema invalid
- [ ] Verify RuleConfig dataclass exists and includes all required fields (from Story 3.1)
- [ ] Create `scripts/print_rules.py` to load rules and print summary (for verification)
  - Print: total rules count, enabled/disabled count, condition types used, action types used

**Task 4: Create Regression Test Harness** (AC: 7)
- [ ] Create fixture file `tests/fixtures/legacy_bookings.json` with 5 representative booking scenarios
  - Booking 1: New booking (no DB record)
  - Booking 2: Booking in 2-hour window (remind_sms not set)
  - Booking 3: Booking at 8 PM with option keyword (option_sms not set)
  - Booking 4: Booking already processed (all flags set)
  - Booking 5: Booking from non-matching store
- [ ] Create baseline file `tests/fixtures/legacy_expected_actions.json` with expected action sequences
  - For each booking fixture, record exact actions that should execute:
    - Action type (send_sms, update_flag, etc.)
    - Parameters (template type, flag name, etc.)
    - Expected outcome (SMS sent, DB updated, etc.)
- [ ] Implement `tests/integration/test_rules_regression.py`:
  - Load rules.yaml and initialize RuleEngine
  - For each booking fixture:
    1. Call RuleEngine.process_booking(booking)
    2. Capture action sequence from rule execution
    3. Compare against baseline sequence
    4. Assert exact match (same action types, same parameters, same order)
    5. Record result (pass/fail) with timestamp
  - Save execution report to VALIDATION.md
  - Fail test if ANY booking produces different action sequence

**Task 5: Create Schema Validation Unit Tests** (AC: 9, 10)
- [ ] Implement `tests/unit/test_rules_schema.py`:
  - Test Case 1: Valid rules.yaml loads successfully without errors
  - Test Case 2: Missing required field `name` produces ValidationError with clear message
  - Test Case 3: Missing required field `conditions` produces ValidationError
  - Test Case 4: Invalid condition type (e.g., `invalid_type`) produces ValidationError
  - Test Case 5: Invalid action type produces ValidationError
  - Test Case 6: Missing required condition parameter (e.g., `time_before_booking` without `hours`) produces ValidationError
  - Test Case 7: Wrong parameter type (e.g., `hours: "string"` instead of int) produces ValidationError
  - Test Case 8: Empty conditions array produces ValidationError
  - Test Case 9: Optional fields (tags, priority, notes) are truly optional (no error if missing)
  - Test Case 10: Invalid enum value in send_sms template produces ValidationError

**Task 6: Setup CI Linting** (AC: 10)
- [ ] Configure yamllint in pre-commit hooks (`.pre-commit-config.yaml`):
  - Rule: YAML formatting validation for rules.yaml
  - Check: No trailing whitespace, proper indentation (2 spaces), line length <120
- [ ] Configure spectral in CI pipeline (`.github/workflows/validate.yml` or equivalent):
  - Step: Run spectral validation against rules.yaml using rules.schema.json
  - Fail build if validation fails
- [ ] Add Make target `make validate-rules` to run both checks locally
- [ ] Update CI configuration to run validation on pull requests

**Task 7: Create Documentation** (AC: 8, 11)
- [ ] Create `docs/rules/rules-config.md` with:
  - Section 1: File Structure Explanation
    - Describe YAML structure (rules array, rule objects, conditions, actions)
    - Explain enabled/disabled rule behavior
    - Show example of each condition type with parameters
    - Show example of each action type with parameters
  - Section 2: Editing Guidelines for Rule Authors
    - How to enable/disable existing rules (change `enabled: true/false`)
    - How to add new rule (copy template, update name/description/conditions/actions)
    - How to modify rule conditions (add/remove conditions, update parameters)
    - How to modify rule actions (add/remove actions, update parameters)
    - Examples: "Add rule to send SMS to store 1051707 only" + "Add rule for date range filtering"
  - Section 3: Testing Workflow
    - Steps to test rules locally before deployment
    - How to run regression test harness
    - How to interpret test results
    - How to roll back if issues detected
  - Section 4: Versioning and Change Log
    - Use semantic versioning (v1.0, v1.1, etc.)
    - Add change log entries to rules.yaml header with date, version, author, description
    - Link to Git commit for auditability
  - Section 5: Common Troubleshooting
    - "Rule not executing" → Check enabled flag, condition parameters
    - "Wrong SMS sent" → Check template name matches send_sms parameters
    - "Duplicate SMS" → Check flag update actions are present

**Task 8: Create Validation Evidence** (AC: 7, 11)
- [ ] Create `VALIDATION.md` with:
  - Section: Regression Test Results
    - Test date, executor, rules.yaml version tested
    - For each booking fixture:
      - Fixture name and description
      - Expected action sequence (from baseline)
      - Actual action sequence (from new rule engine)
      - Result (✅ PASS or ❌ FAIL)
      - Differences if any (detailed comparison)
    - Summary: Total bookings tested, pass rate, any failures
  - Section: Schema Validation Results
    - Schema version tested, validation tool (jsonschema, spectral)
    - Test date and executor
    - All test cases passed/failed count
  - Section: Change Log
    - Version 1.0 created (this story)
    - Link to commit
    - Author and date

---

## Definition of Done

- [ ] All tasks completed and subtasks checked
- [ ] rules.yaml created at `src/config/rules.yaml` with 3 active rules + 2 disabled templates
- [ ] rules.schema.json created at `src/config/rules.schema.json` with valid JSON Schema
- [ ] Configuration loader (Settings.load) successfully loads and validates rules.yaml
- [ ] Regression test harness passes: 100% action sequence match with legacy system
- [ ] Schema validation tests pass: All 10 test cases pass
- [ ] CI linting configured: yamllint and spectral integrated
- [ ] Documentation complete: docs/rules/rules-config.md with all 5 sections
- [ ] Evidence captured: VALIDATION.md with regression results and schema validation results
- [ ] No warnings or errors in make fmt && make test && make lint
- [ ] All files committed to Git with descriptive commit message

---

## Risk and Compatibility Check

- **Primary Risk:** Misconfigured YAML causing missed or duplicated SMS events.  
  **Mitigation:** Regression harness, schema validation, manual review by PO/QA before deployment.
- **Rollback:** Revert to previous `rules.yaml` version via Git; rule engine loads last known good configuration.

**Compatibility Verification**
- [x] Compatible with rule engine core and evaluators/executors  
- [x] Supports future extensions (Slack, date ranges) via disabled templates  
- [x] Aligns with PRD requirement for configuration-driven rules

---

## Example rules.yaml Structure

For reference, here's the complete structure for the main three rules:

```yaml
# rules.yaml - SMS Automation Rules Configuration
# Version: 1.0
# Last Updated: 2025-10-18 by Sarah (PO)
# Schema: config/rules.schema.json
# Change Log: See end of file

rules:
  # Rule 1: New Booking Confirmation
  - name: "New Booking Confirmation"
    enabled: true
    description: "Send confirmation SMS when new booking detected in system"
    tags: ["core", "confirmation"]
    priority: "high"
    conditions:
      - type: "booking_not_in_db"
    actions:
      - type: "create_db_record"
      - type: "send_sms"
        params:
          template: "confirmation"
      - type: "send_telegram"
        params:
          message: "[SMS] Confirmation sent to customer"

  # Rule 2: Two-Hour Reminder
  - name: "Two-Hour Reminder"
    enabled: true
    description: "Send reminder SMS 2 hours before booking"
    tags: ["core", "reminder"]
    priority: "high"
    conditions:
      - type: "time_before_booking"
        params:
          hours: 2
      - type: "flag_not_set"
        params:
          flag: "remind_sms"
    actions:
      - type: "send_sms"
        params:
          template: "guide"
          store_specific: true
      - type: "update_flag"
        params:
          flag: "remind_sms"
          value: true

  # Rule 3: Evening Option SMS
  - name: "Evening Option SMS"
    enabled: true
    description: "Send option-related SMS at 8 PM for customers with option selections"
    tags: ["core", "option"]
    priority: "medium"
    conditions:
      - type: "current_hour"
        params:
          hour: 20
      - type: "flag_not_set"
        params:
          flag: "option_sms"
      - type: "has_option_keyword"
        params:
          keywords: ["네이버", "인스타", "원본"]
    actions:
      - type: "send_sms"
        params:
          template: "event"
      - type: "update_flag"
        params:
          flag: "option_sms"
          value: true

  # Template: Slack Notification (DISABLED - Future Enhancement)
  - name: "Slack Notification (Template)"
    enabled: false
    description: "[FUTURE] Send SMS summary to Slack channel daily"
    tags: ["future", "notification"]
    priority: "low"
    conditions:
      - type: "current_hour"
        params:
          hour: 22
    actions:
      - type: "send_slack"
        params:
          channel: "#sms-automation"
          message: "Daily SMS Summary: [to be implemented]"

  # Template: Date Range Rule (DISABLED - Future Enhancement)
  - name: "Date Range Promotion (Template)"
    enabled: false
    description: "[FUTURE] Send promotional SMS only during specified date ranges"
    tags: ["future", "promotion"]
    priority: "low"
    conditions:
      - type: "date_range"
        params:
          start_date: "2025-11-01"
          end_date: "2025-11-30"
      - type: "store_id_matches"
        params:
          store_ids: [1051707]
    actions:
      - type: "send_sms"
        params:
          template: "custom_promotion"

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-19 | 1.1 | Story updated: Added Dev Notes, Tasks/Subtasks, Dependency Checkpoints per validation feedback | Sarah (PO) |
| 2025-10-18 | 1.0 | Story drafted from Epic 3 requirements | Sarah (PO) |

