# Story 3.1: Implement Rule Engine Core

**Status:** Draft

---

## Story

**As a** developer,
**I want** to implement the core rule engine that loads, validates, and executes rules,
**so that** business logic can be configured via YAML instead of hardcoded in Python.

**This is the PRIMARY BUSINESS VALUE** of the entire refactoring project.

---

## Acceptance Criteria

1. Rule engine loads rules from `config/rules.yaml`
2. Rule schema validation catches invalid configurations
3. Rule engine evaluates all conditions for a booking (AND logic)
4. Rule engine executes all actions in sequence when conditions met
5. Rule engine handles errors gracefully (log and continue to next rule)
6. Condition and action registries support dynamic registration
7. Context object provides all data needed for evaluation
8. Rule engine returns structured results (which rules matched, actions taken)
9. Performance: <100ms per rule evaluation
10. Unit tests pass with >80% coverage
11. Integration tests validate end-to-end rule execution

---

## Tasks / Subtasks

- [ ] Create `src/rules/engine.py` module (AC: 1, 2)
  - [ ] Implement `RuleConfig` data class (from YAML structure)
  - [ ] Implement `RuleEngine` class
  - [ ] Load rules from YAML file
  - [ ] Validate rule schema on load

- [ ] Implement condition evaluation (AC: 3, 6)
  - [ ] Create condition evaluator registry
  - [ ] Implement `register_condition(name, evaluator_func)`
  - [ ] Implement `evaluate_rule(rule, context)` - check all conditions
  - [ ] Support AND logic for multiple conditions

- [ ] Implement action execution (AC: 4, 6)
  - [ ] Create action executor registry
  - [ ] Implement `register_action(name, executor_func)`
  - [ ] Implement `execute_rule(rule, context)` - run all actions
  - [ ] Support action parameters

- [ ] Implement context builder (AC: 7)
  - [ ] Create `build_context(booking, db_client, current_time)`
  - [ ] Include booking data, DB record, current time, settings

- [ ] Error handling (AC: 5)
  - [ ] Try/catch around condition evaluation
  - [ ] Try/catch around action execution
  - [ ] Log errors with context
  - [ ] Continue to next rule on error

- [ ] Create result tracking (AC: 8)
  - [ ] `ActionResult` data class (action, success, message)
  - [ ] Collect results from all rules
  - [ ] Return structured results

- [ ] Performance optimization (AC: 9)
  - [ ] Profile rule evaluation
  - [ ] Optimize if needed (<100ms target)

- [ ] Unit tests (AC: 10)
  - [ ] Test rule loading and validation
  - [ ] Test condition evaluation (mocked evaluators)
  - [ ] Test action execution (mocked executors)
  - [ ] Test error handling
  - [ ] Test result tracking

- [ ] Integration tests (AC: 11)
  - [ ] Test with sample rules and real evaluators
  - [ ] Test end-to-end rule processing

---

## Dev Notes

### Context from Architecture Document

**Current Hardcoded Logic:**
- 12 condition patterns scattered across lambda_function.py
- 9 action patterns in multiple functions
- No separation between condition evaluation and action execution
- Cannot add new rules without code changes

**Target Rule Engine:**
- Declarative rules in YAML
- Pluggable conditions and actions
- Easy to add new rules (edit YAML only)
- Easy to add new condition/action types (register functions)

**References:**
- Architecture Doc: Lines 1070-1106 (Rule Engine Design)
- Architecture Doc: Lines 394-465 (Current Hardcoded Logic Mapping)
- Architecture Doc: Lines 1425-1430 (Epic 3 Context)
- PRD: Section 4.1 FR1-FR3 (Rule Engine Requirements)
- requierment.md: Lines 1-2 (Original Korean requirement)

### Rule Engine Architecture

**Core Classes:**

```python
# src/rules/engine.py
from dataclasses import dataclass
from typing import List, Dict, Callable, Any, Optional
import yaml
import logging

logger = logging.getLogger(__name__)

@dataclass
class ConditionConfig:
    """Configuration for a single condition"""
    type: str  # e.g., "booking_not_in_db"
    params: Dict[str, Any] = None  # Optional parameters

@dataclass
class ActionConfig:
    """Configuration for a single action"""
    type: str  # e.g., "send_sms"
    params: Dict[str, Any] = None  # Optional parameters

@dataclass
class RuleConfig:
    """Configuration for a complete rule"""
    name: str
    enabled: bool
    conditions: List[ConditionConfig]
    actions: List[ActionConfig]
    description: Optional[str] = None

@dataclass
class ActionResult:
    """Result of executing an action"""
    rule_name: str
    action_type: str
    success: bool
    message: str
    error: Optional[str] = None

class RuleEngine:
    """
    Core rule engine that evaluates conditions and executes actions.
    """

    def __init__(self, rules_config_path: str):
        self.rules: List[RuleConfig] = []
        self.condition_evaluators: Dict[str, Callable] = {}
        self.action_executors: Dict[str, Callable] = {}
        self.load_rules(rules_config_path)

    def load_rules(self, config_path: str):
        """
        Load rules from YAML configuration file.

        Args:
            config_path: Path to rules.yaml

        Raises:
            ValueError: If rule schema is invalid
            FileNotFoundError: If config file not found
        """
        with open(config_path, 'r') as f:
            config = yaml.safe_load(f)

        # Validate and parse rules
        for rule_data in config.get('rules', []):
            rule = self._parse_rule(rule_data)
            self.rules.append(rule)

        logger.info(f"Loaded {len(self.rules)} rules from {config_path}")

    def _parse_rule(self, rule_data: Dict) -> RuleConfig:
        """
        Parse and validate a single rule from YAML data.

        Args:
            rule_data: Dict from YAML

        Returns:
            RuleConfig object

        Raises:
            ValueError: If rule schema is invalid
        """
        # Validate required fields
        if 'name' not in rule_data:
            raise ValueError("Rule missing required field: name")
        if 'conditions' not in rule_data:
            raise ValueError(f"Rule '{rule_data['name']}' missing conditions")
        if 'actions' not in rule_data:
            raise ValueError(f"Rule '{rule_data['name']}' missing actions")

        # Parse conditions
        conditions = [
            ConditionConfig(
                type=c['type'],
                params=c.get('params', {})
            )
            for c in rule_data['conditions']
        ]

        # Parse actions
        actions = [
            ActionConfig(
                type=a['type'],
                params=a.get('params', {})
            )
            for a in rule_data['actions']
        ]

        return RuleConfig(
            name=rule_data['name'],
            enabled=rule_data.get('enabled', True),
            conditions=conditions,
            actions=actions,
            description=rule_data.get('description')
        )

    def register_condition(self, name: str, evaluator: Callable):
        """
        Register a condition evaluator function.

        Args:
            name: Condition type name (e.g., "booking_not_in_db")
            evaluator: Function(context, **params) -> bool
        """
        self.condition_evaluators[name] = evaluator
        logger.debug(f"Registered condition evaluator: {name}")

    def register_action(self, name: str, executor: Callable):
        """
        Register an action executor function.

        Args:
            name: Action type name (e.g., "send_sms")
            executor: Function(context, **params) -> None
        """
        self.action_executors[name] = executor
        logger.debug(f"Registered action executor: {name}")

    def evaluate_rule(self, rule: RuleConfig, context: Dict) -> bool:
        """
        Evaluate all conditions for a rule (AND logic).

        Args:
            rule: RuleConfig to evaluate
            context: Context dict with booking, db_record, current_time, etc.

        Returns:
            True if all conditions met, False otherwise
        """
        if not rule.enabled:
            return False

        for condition in rule.conditions:
            evaluator = self.condition_evaluators.get(condition.type)
            if not evaluator:
                logger.error(f"Unknown condition type: {condition.type}")
                return False

            try:
                params = condition.params or {}
                result = evaluator(context, **params)
                if not result:
                    logger.debug(f"Rule '{rule.name}' condition '{condition.type}' failed")
                    return False
            except Exception as e:
                logger.error(f"Error evaluating condition '{condition.type}' in rule '{rule.name}': {e}")
                return False

        # All conditions met
        logger.info(f"Rule '{rule.name}' conditions all met")
        return True

    def execute_rule(self, rule: RuleConfig, context: Dict) -> List[ActionResult]:
        """
        Execute all actions for a rule.

        Args:
            rule: RuleConfig to execute
            context: Context dict

        Returns:
            List of ActionResult objects
        """
        results = []

        for action in rule.actions:
            executor = self.action_executors.get(action.type)
            if not executor:
                logger.error(f"Unknown action type: {action.type}")
                results.append(ActionResult(
                    rule_name=rule.name,
                    action_type=action.type,
                    success=False,
                    message="Unknown action type",
                    error=f"No executor registered for '{action.type}'"
                ))
                continue

            try:
                params = action.params or {}
                executor(context, **params)
                results.append(ActionResult(
                    rule_name=rule.name,
                    action_type=action.type,
                    success=True,
                    message=f"Action '{action.type}' executed successfully"
                ))
            except Exception as e:
                logger.error(f"Error executing action '{action.type}' in rule '{rule.name}': {e}")
                results.append(ActionResult(
                    rule_name=rule.name,
                    action_type=action.type,
                    success=False,
                    message=f"Action '{action.type}' failed",
                    error=str(e)
                ))

        return results

    def process_booking(self, context: Dict) -> List[ActionResult]:
        """
        Main entry point: process a booking through all rules.

        Args:
            context: Context dict with booking, db_record, current_time, etc.

        Returns:
            List of ActionResult objects from all matched rules
        """
        all_results = []

        for rule in self.rules:
            if self.evaluate_rule(rule, context):
                results = self.execute_rule(rule, context)
                all_results.extend(results)

        return all_results
```

**Context Builder:**

```python
# src/rules/context.py
from datetime import datetime
from typing import Dict, Any

def build_context(booking, db_client, settings) -> Dict[str, Any]:
    """
    Build context object for rule evaluation.

    Args:
        booking: Booking domain object
        db_client: DynamoDB client
        settings: Application settings

    Returns:
        Dict with all data needed for rule evaluation
    """
    # Get DB record if exists
    db_record = db_client.get_booking_record(
        booking_num=f"{booking.biz_id}_{booking.book_id}",
        phone=booking.phone
    )

    return {
        'booking': booking,
        'db_record': db_record,
        'current_time': datetime.now(),
        'settings': settings,
        'db_client': db_client
    }
```

### Example rules.yaml

```yaml
# config/rules.yaml
rules:
  - name: "New Booking Confirmation"
    description: "Send confirmation SMS to new bookings"
    enabled: true
    conditions:
      - type: "booking_not_in_db"
    actions:
      - type: "create_db_record"
      - type: "send_sms"
        params:
          template: "confirmation"
      - type: "send_telegram"
        params:
          message: "Confirmation SMS sent to {{booking.phone}}"

  - name: "Two Hour Reminder"
    description: "Send guide SMS 2 hours before reservation"
    enabled: true
    conditions:
      - type: "time_before_booking"
        params:
          hours: 2
      - type: "flag_not_set"
        params:
          flag: "remind_sms"
    actions:
      - type: "send_sms"
        params:
          template: "guide"
          store_specific: true
      - type: "update_flag"
        params:
          flag: "remind_sms"
          value: true

  - name: "Evening Event SMS"
    description: "Send event SMS at 8 PM for completed bookings with options"
    enabled: true
    conditions:
      - type: "current_hour"
        params:
          hour: 20
      - type: "booking_status"
        params:
          status: "RC08"
      - type: "flag_not_set"
        params:
          flag: "option_sms"
      - type: "has_option_keyword"
    actions:
      - type: "send_sms"
        params:
          template: "event"
      - type: "update_flag"
        params:
          flag: "option_sms"
          value: true
```

### Testing

**Unit Tests (tests/unit/test_rule_engine.py):**

```python
import pytest
from rules.engine import RuleEngine, RuleConfig, ConditionConfig, ActionConfig
from unittest.mock import Mock

def test_load_rules_from_yaml(tmp_path):
    """Test loading rules from YAML file"""
    # Create test YAML
    rules_file = tmp_path / "test_rules.yaml"
    rules_file.write_text("""
rules:
  - name: "Test Rule"
    enabled: true
    conditions:
      - type: "test_condition"
        params:
          value: 42
    actions:
      - type: "test_action"
""")

    engine = RuleEngine(str(rules_file))
    assert len(engine.rules) == 1
    assert engine.rules[0].name == "Test Rule"
    assert engine.rules[0].enabled == True
    assert len(engine.rules[0].conditions) == 1
    assert engine.rules[0].conditions[0].type == "test_condition"

def test_register_condition():
    """Test condition evaluator registration"""
    engine = RuleEngine("config/rules.yaml")

    def mock_evaluator(context, **params):
        return True

    engine.register_condition("test_condition", mock_evaluator)
    assert "test_condition" in engine.condition_evaluators

def test_evaluate_rule_all_conditions_met():
    """Test rule evaluation when all conditions pass"""
    engine = RuleEngine("config/rules.yaml")

    # Register mock condition
    engine.register_condition("always_true", lambda ctx, **p: True)

    rule = RuleConfig(
        name="Test",
        enabled=True,
        conditions=[ConditionConfig(type="always_true")],
        actions=[]
    )

    context = {'booking': Mock()}
    assert engine.evaluate_rule(rule, context) == True

def test_evaluate_rule_condition_fails():
    """Test rule evaluation when a condition fails"""
    engine = RuleEngine("config/rules.yaml")

    # Register conditions
    engine.register_condition("always_true", lambda ctx, **p: True)
    engine.register_condition("always_false", lambda ctx, **p: False)

    rule = RuleConfig(
        name="Test",
        enabled=True,
        conditions=[
            ConditionConfig(type="always_true"),
            ConditionConfig(type="always_false")  # This fails
        ],
        actions=[]
    )

    context = {'booking': Mock()}
    assert engine.evaluate_rule(rule, context) == False

def test_execute_rule_actions():
    """Test action execution"""
    engine = RuleEngine("config/rules.yaml")

    # Register mock action
    action_executed = []
    def mock_action(ctx, **params):
        action_executed.append(params)

    engine.register_action("test_action", mock_action)

    rule = RuleConfig(
        name="Test",
        enabled=True,
        conditions=[],
        actions=[
            ActionConfig(type="test_action", params={'key': 'value'})
        ]
    )

    context = {'booking': Mock()}
    results = engine.execute_rule(rule, context)

    assert len(results) == 1
    assert results[0].success == True
    assert len(action_executed) == 1
    assert action_executed[0] == {'key': 'value'}

def test_process_booking_end_to_end():
    """Test complete booking processing through rules"""
    engine = RuleEngine("config/rules.yaml")

    # Register condition and action
    engine.register_condition("booking_is_new", lambda ctx, **p: ctx['booking'].is_new)

    actions_taken = []
    def log_action(ctx, **params):
        actions_taken.append(params['message'])

    engine.register_action("log", log_action)

    # Add rule to engine
    engine.rules = [
        RuleConfig(
            name="Test Rule",
            enabled=True,
            conditions=[ConditionConfig(type="booking_is_new")],
            actions=[ActionConfig(type="log", params={'message': 'Action taken'})]
        )
    ]

    # Create context
    booking = Mock()
    booking.is_new = True
    context = {'booking': booking}

    # Process
    results = engine.process_booking(context)

    assert len(results) == 1
    assert results[0].success == True
    assert 'Action taken' in actions_taken
```

### Testing Standards

**Test File Location:** `tests/unit/test_rule_engine.py`

**Coverage Requirement:** >80%

**Key Tests:**
- Rule loading from YAML
- Rule validation (invalid YAML)
- Condition registration
- Action registration
- Condition evaluation (pass/fail)
- Action execution (success/error)
- Error handling (unknown condition/action)
- End-to-end processing

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-18 | 1.0 | Story created from Epic 3 | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used
(To be populated by dev agent)

### Debug Log References
(To be populated by dev agent)

### Completion Notes List
(To be populated by dev agent)

### File List
(To be populated by dev agent)

---

## QA Results
(To be populated by QA agent)
