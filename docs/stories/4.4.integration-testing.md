# Story 4.4: Integration Testing

**Status:** Approved

---

## Story

**As a** quality-focused release engineer,\
**I want** to execute end-to-end integration and parity testing for the containerized Lambda,\
**so that** we can prove the refactored system matches production behavior before cutover.

This story validates the refactored pipeline against real booking flows so deployment decisions can rely on measurable parity evidence.

---

## Acceptance Criteria

1. Comparison suite replays the sanitized legacy dataset through both the legacy baseline and the containerized Lambda via Lambda RIE, asserting SMS, DynamoDB, and Telegram outputs match exactly and surfacing structured diffs on any mismatch. [Source: docs/brownfield-architecture.md#comparison-testing-strategy] [Source: docs/brownfield-architecture.md#container-tests] [Source: docs/brownfield-architecture.md#testing-strategy-for-this-epic]
2. Integration tests cover the happy path (login -> booking fetch -> rule engine -> notifications) and failure scenarios (Naver API outage, DynamoDB unavailable), confirming Telegram alert behavior and resilient error handling. [Source: docs/brownfield-architecture.md#testing-strategy-for-this-epic] [Source: docs/brownfield-architecture.md#integration-points-and-external-dependencies]
3. A one-week sanitized booking dataset capturing edge cases (two-hour reminders, option keywords, cookie expiry, empty bookings) is stored under versioned fixtures with documented refresh steps. [Source: docs/brownfield-architecture.md#test-data-requirements] [Source: docs/brownfield-architecture.md#comparison-testing-strategy]
4. Developer-facing documentation and scripts detail building the container, running `docker run --rm -p 9000:8080 --env-file .env ...`, and invoking the Lambda RIE regression harness with required environment variables. [Source: docs/brownfield-architecture.md#local-development-setup-after-ecr-migration] [Source: docs/brownfield-architecture.md#container-tests] [Source: docs/dev/local-setup.md#local-development-setup-guide]
5. CI executes the comparison and integration suites with an >=80% coverage gate and fails the pipeline on parity deltas or regression failures, using the recommended pytest commands. [Source: docs/brownfield-architecture.md#recommended-test-strategy] [Source: docs/brownfield-architecture.md#testing-reality] [Source: docs/testing/rule-engine-tests.md#ci-cd-integration]
6. Parity runs produce an auditable summary (logs or report artifact) that records dataset version, container digest, and discrepancy outcomes for release readiness sign-off. [Source: docs/brownfield-architecture.md#comparison-testing-strategy]
7. Slack notification executor configuration is documented and validated alongside Telegram alerts so release reporting can be dual-routed when Slack is enabled. [Source: docs/brownfield-architecture.md#action-executors-src-rules-actions.py] [Source: docs/stories/4.3.build-docker-container.md#dev-notes]

---

## Tasks / Subtasks

- [ ] Task 1: Capture and sanitize baseline datasets (AC: 1, 3)  
  - [ ] Export one week of legacy inputs/outputs, mask PII per architecture guidance, and store fixtures under `tests/fixtures/` with metadata. [Source: docs/brownfield-architecture.md#test-data-requirements]  
  - [ ] Persist baseline SMS, DynamoDB, and Telegram results for comparison harness consumption alongside dataset manifest checksums. [Source: docs/brownfield-architecture.md#comparison-testing-strategy]

- [ ] Task 2: Implement automated parity harness (AC: 1, 6)  
  - [ ] Extend `tests/comparison/test_output_parity.py` (or equivalent) to replay fixtures through the containerized handler and assert parity against legacy outputs. [Source: docs/brownfield-architecture.md#comparison-testing-strategy]  
  - [ ] Emit human-readable and machine-consumable diff artifacts (e.g., JSON + Markdown) capturing discrepancies, dataset version, and container digest, storing them as `tests/comparison/artifacts/parity_run.json` and `tests/comparison/artifacts/parity_run.md`. [Source: docs/brownfield-architecture.md#comparison-testing-strategy]

- [ ] Task 3: Expand integration test coverage (AC: 2, 5)  
  - [ ] Add integration tests that execute the full login -> fetch -> process -> notify flow using fixtures and Lambda RIE-compatible stubs. [Source: docs/brownfield-architecture.md#testing-strategy-for-this-epic]  
  - [ ] Introduce failure-injection tests for Naver API and DynamoDB outages that verify Telegram alert pathways. [Source: docs/brownfield-architecture.md#testing-strategy-for-this-epic]  
  - [ ] Ensure integration tests adopt existing pytest patterns and markers for consistent execution. [Source: docs/testing/rule-engine-tests.md#key-testing-patterns]

- [ ] Task 4: Document and automate execution workflows (AC: 4, 5, 7)  
  - [ ] Update developer documentation with container build/run instructions, `.env` expectations, invocation commands for regression harnesses, and Slack notification configuration toggles. [Source: docs/brownfield-architecture.md#local-development-setup-after-ecr-migration] [Source: docs/dev/local-setup.md#step-2-bootstrap-environment] [Source: docs/brownfield-architecture.md#action-executors-src-rules-actions.py]  
  - [ ] Wire CI workflows that run comparison + integration suites with coverage gates, fail on parity deltas, and publish Slack-ready summary artifacts. [Source: docs/brownfield-architecture.md#recommended-test-strategy] [Source: docs/testing/rule-engine-tests.md#ci-cd-integration] [Source: docs/brownfield-architecture.md#action-executors-src-rules-actions.py]

- [ ] Task 5: Verify Slack notification path (AC: 7)  
  - [ ] Extend integration or parity tests with Slack executor stubs that assert summary payload structure when Slack is enabled. [Source: docs/brownfield-architecture.md#action-executors-src-rules-actions.py]  
  - [ ] Record Slack configuration requirements (Secret Manager keys, optional enable flag) in regression documentation. [Source: docs/brownfield-architecture.md#critical-technical-debt]

---

## Dev Notes

### Previous Story Insights

- Story 4.3 remains in Draft; completion of the container build (Dockerfile, tagging, Lambda RIE validation) is a prerequisite for executing this integration suite. [Source: docs/stories/4.3.build-docker-container.md#acceptance-criteria]

### Data Models

- Booking fixtures must retain normalized phone formatting, KST timestamp conversion, and option flags consistent with the domain model enforced by the rule engine. [Source: docs/brownfield-architecture.md#data-models-and-persistence]
- DynamoDB records leverage composite keys `{booking_num, phone}` with confirm/remind/option flags that parity checks must evaluate. [Source: docs/brownfield-architecture.md#data-models-and-persistence]

### Integration & Comparison Harness

- Comparison harness flows replay captured bookings through both implementations and assert parity across SMS sends, DynamoDB mutations, Telegram outputs, and optional Slack notifications. [Source: docs/brownfield-architecture.md#comparison-testing-strategy] [Source: docs/brownfield-architecture.md#action-executors-src-rules-actions.py]
- Regression outputs should highlight discrepancies clearly to accelerate triage before deployment. [Source: docs/brownfield-architecture.md#comparison-testing-strategy]

### Component Specifications

- Integration tests must traverse Naver authentication, booking API requests, rule engine execution, and notification dispatch (Telegram and optional Slack) to reflect production behavior. [Source: docs/brownfield-architecture.md#integration-points-and-external-dependencies] [Source: docs/brownfield-architecture.md#action-executors-src-rules-actions.py]
- When failure scenarios are simulated, Telegram alert pathways defined in the architecture must be triggered and asserted, and Slack should be exercised when enabled. [Source: docs/brownfield-architecture.md#testing-strategy-for-this-epic] [Source: docs/brownfield-architecture.md#action-executors-src-rules-actions.py]

### Test Data Handling

- Sanitized fixtures require masking phone numbers, names, and secrets while preserving behaviorally significant fields (option keywords, timestamps). [Source: docs/brownfield-architecture.md#test-data-requirements]
- Fixture manifests should capture dataset coverage for edge cases like empty booking runs and cookie expiry. [Source: docs/brownfield-architecture.md#test-data-requirements]

### Environment & Tooling

- Regression harnesses must document `docker build`, `docker run --rm -p 9000:8080 --env-file .env`, and Lambda invoke commands for local verification. [Source: docs/brownfield-architecture.md#local-development-setup-after-ecr-migration]
- Local development guide outlines AWS profile, Secrets Manager access, and bootstrap script requirements for running integration tests. [Source: docs/dev/local-setup.md#local-development-setup-guide]

### File Locations

- Comparison tests target `tests/comparison/test_output_parity.py`, while broader integration flows live under `tests/integration/`. [Source: docs/brownfield-architecture.md#comparison-testing-strategy] [Source: docs/testing/rule-engine-tests.md#test-organization]
- Fixture data resides under `tests/fixtures/legacy_*.json` and should be extended for integration scenarios. [Source: docs/testing/rule-engine-tests.md#test-organization]

### Testing Requirements

- Integration suite should follow pytest patterns (pure condition tests, mocked actions, end-to-end workflows) already documented for the rule engine. [Source: docs/testing/rule-engine-tests.md#key-testing-patterns]
- CI automation must reuse or extend the GitHub Actions workflow that runs pytest with coverage gates. [Source: docs/testing/rule-engine-tests.md#ci-cd-integration]

### Technical Constraints

- Secrets and credentials must remain sourced from AWS Secrets Manager or approved local overrides to avoid reintroducing hardcoded secrets. [Source: docs/brownfield-architecture.md#critical-technical-debt]
- Maintain >=80% coverage for new test code and ensure logs redact sensitive values during failure scenarios. [Source: docs/brownfield-architecture.md#testing-reality]

### Project Structure Notes

- Place new regression documentation alongside existing testing references in `docs/testing/` to keep quality guidance centralized. [Source: docs/testing/rule-engine-tests.md#overview]
- Align new scripts with the established source tree to avoid divergence from the architecture's recommended layout. [Source: docs/brownfield-architecture.md#project-structure-actual]

### Testing

- `python -m pytest tests/comparison/test_output_parity.py -v --cov=src --cov-report=term-missing` [Source: docs/brownfield-architecture.md#comparison-testing-strategy]
- `python -m pytest tests/integration/test_rule_engine_integration.py -v` [Source: docs/testing/rule-engine-tests.md#run-single-test]
- `pytest tests -m integration --maxfail=1` (pre-commit marker run) [Source: docs/testing/rule-engine-tests.md#key-testing-patterns]

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-22 | 1.0 | Story drafted for Integration Testing parity plan | Bob (Scrum Master) |

---

## Dev Agent Record

### Agent Model Used

_To be populated by dev agent_

### Debug Log References

_To be populated by dev agent_

### Completion Notes List

_To be populated by dev agent_

### File List

_To be populated by dev agent_

---

## QA Results

_To be populated by QA agent_
