# Story 6.2: Add Slack Integration

**Status:** Done

---

## Quick Project Assessment

**Current System Context**
- [x] Rule engine actions are defined in `src/rules/actions.py`, where `send_slack` is a placeholder that only logs when Slack is enabled. [Source: src/rules/actions.py:526]
- [x] `src/notifications/slack_service.py` provides a production-ready Slack webhook client with retry handling that is not yet wired into the rule engine. [Source: src/notifications/slack_service.py]
- [x] Webhook URL is stored in `config/my_slack_webhook.yaml` for local development and Secrets Manager for production deployment. [Source: config/my_slack_webhook.yaml]
- [x] Message templates are defined in `config/slack_templates.yaml` using Jinja2 format (e.g., `expert_correction_digest`). [Source: config/slack_templates.yaml]
- [x] Slack notifications are triggered as an **action** when booking conditions match (e.g., "expert correction" keyword detected in `src/api/naver_booking.py`). [Source: src/api/naver_booking.py]
- [x] Runtime configuration is loaded through `src/config/settings.py`, which currently exposes feature flags but no Slack-specific toggles. [Source: src/config/settings.py]

**Change Scope**
- [x] Replace the `send_slack` action placeholder with a real integration that leverages `SlackWebhookClient` using **webhook-only delivery** (single delivery method). [Source: src/rules/actions.py]
- [x] Wire Slack action to use templates from `config/slack_templates.yaml` and webhook URL from `config/my_slack_webhook.yaml` (or Secrets Manager in production).
- [x] Enable/disable Slack delivery safely via runtime configuration toggle.
- [x] Integrate with existing booking condition system so "expert correction" conditions (from `src/api/naver_booking.py`) trigger Slack notifications without requiring separate configuration. [Source: src/api/naver_booking.py]

---

## Story

**As a** platform operations engineer,  
**I want** the rule engine to dispatch Slack notifications through the existing webhook client with proper configuration toggles,  
**so that** downstream stories can add Slack-based rules using configuration only.

---

## Acceptance Criteria

1. `send_slack` in `src/rules/actions.py` uses `SlackWebhookClient` with **webhook-only delivery** to dispatch messages, supports `channel`, `message`, and optional `template_name` parameters, and surfaces failures via `ActionExecutionError` while logging structured metadata. [Source: src/rules/actions.py]
2. Slack configuration is sourced from `config/my_slack_webhook.yaml` (local) or Secrets Manager (production) into `Settings`, exposing `slack_enabled` and webhook URL; when Slack is disabled the action exits early without errors. [Source: config/my_slack_webhook.yaml]
3. Message templates in `config/slack_templates.yaml` (e.g., `expert_correction_digest`) are loaded and rendered using Jinja2 substitution; template loader exposes named templates for rule consumption. [Source: config/slack_templates.yaml]
4. Slack notifications are triggered automatically when rule conditions match (e.g., "expert correction" keyword from `src/api/naver_booking.py`); no additional booking-specific configuration needed. [Source: src/api/naver_booking.py]
5. Integration tests in `tests/integration/test_slack_integration.py` exercise the wired action, validating template rendering, toggle behavior, and error handling with mocked webhooks. [Source: tests/integration/test_slack_integration.py]
6. Documentation (`docs/testing/slack-integration.md`) reflects webhook configuration, template usage, enable/disable steps, and integration with booking conditions. [Source: docs/testing/slack-integration.md]

---

## Tasks / Subtasks

- [x] Task 1: Wire Slack action executor with webhook delivery (AC: 1, 2, 3)
  - [x] Replace the placeholder logic in `src/rules/actions.py::send_slack` with calls to `SlackWebhookClient`, mapping rule parameters (channel, message, optional template_name) and propagating errors through `ActionExecutionError`. [Source: src/rules/actions.py:651]
  - [x] Implement template loader to read `config/slack_templates.yaml`, parse Jinja2 templates, and inject runtime data (e.g., user list, date). [Source: src/rules/actions.py:53]
  - [x] Extend `ActionServicesBundle` to include a Slack service instance and register it within `register_actions`, ensuring dependency injection mirrors other executors. [Source: src/rules/actions.py:227]
  - [x] Add unit coverage around the new wiring (e.g., `tests/integration/test_slack_integration.py`) to assert the Slack service is invoked with expected payloads and that disabled mode short-circuits. [Source: tests/integration/test_slack_integration.py:98]

- [x] Task 2: Deliver configuration plumbing (AC: 2, 3)
  - [x] Update `src/config/settings.py` to load Slack settings (`slack_enabled` flag and webhook URL) from `config/my_slack_webhook.yaml` (local) or Secrets Manager (production). [Source: src/config/settings.py:293]
  - [x] Ensure `config/slack_templates.yaml` exists with at least `expert_correction_digest` template; implement template loader that parses Jinja2 and validates template names. [Source: config/slack_templates.yaml]
  - [x] Document webhook URL source, template file location, and enable/disable toggle in `.env.example` without exposing sensitive values. [Source: .env.example:28]

- [x] Task 3: Strengthen automated coverage (AC: 5)
  - [x] Add integration tests in `tests/integration/test_slack_integration.py` that mock the webhook client to verify template rendering, channel routing (if applicable), toggle behavior, and error handling. [Source: tests/integration/test_slack_integration.py]
  - [x] Verify that booking conditions (e.g., "expert correction" from `src/api/naver_booking.py`) correctly trigger Slack actions when enabled. [Source: tests/integration/test_slack_integration.py:348]
  - [x] Update regression harness defaults so Slack is disabled during parity runs unless explicitly enabled, preventing flaky comparisons. [Source: src/config/settings.py:41]

- [x] Task 4: Update documentation & ops guidance (AC: 6)
  - [x] Expand `docs/testing/slack-integration.md` with webhook URL configuration (`config/my_slack_webhook.yaml`), template usage (`config/slack_templates.yaml`), enable/disable steps, and integration with booking conditions. [Source: docs/testing/slack-integration.md]
  - [x] Document how "expert correction" conditions from `src/api/naver_booking.py` trigger Slack notifications automatically. [Source: docs/testing/slack-integration.md:337]
  - [x] Add enable/disable checklist for operators (toggle `SLACK_ENABLED` flag via Secrets Manager or `.env`). [Source: docs/testing/slack-integration.md:532]

---

## Dev Notes

- **Webhook-Only Delivery:** Slack messaging uses a single webhook delivery method (no multiple delivery types). Parse webhook URL from `config/my_slack_webhook.yaml`. [Source: config/my_slack_webhook.yaml]
- **Template Rendering:** Implement Jinja2 template loader for `config/slack_templates.yaml`; reuse existing templating utilities if available. Templates support variable substitution (e.g., `{{ today_date }}`, `{% for user in users %}`). [Source: config/slack_templates.yaml]
- **Booking Context:** Slack notifications are triggered by rule conditions matching booking data from `src/api/naver_booking.py` (e.g., "expert correction" keyword). No separate booking-specific logic needed in Slack action. [Source: src/api/naver_booking.py]
- **Existing Pattern Alignment:** Follow the dependency-injection pattern already used for SMS (`ActionServicesBundle` + wrappers) so Slack behaves consistently within the rule engine. [Source: src/rules/actions.py]  
- **Secrets Handling:** Feature flags and webhook URLs must be masked in logs; leverage `StructuredLogger` redaction utilities and avoid printing raw tokens. [Source: src/utils/logger.py]  
- **Toggle Strategy:** Default Slack to disabled in non-production environments until verified; expose an environment flag `SLACK_ENABLED`. [Source: src/config/settings.py]

### Testing

- `pytest tests/rules/test_actions.py -k "slack" -v` (unit coverage for new executor wiring).  
- `pytest tests/integration/test_slack_integration.py -v` (integration suite exercising enable/disable, formatting, error handling).  
- `pytest tests -m integration --cov=src/rules --cov-report=term-missing` (ensure overall coverage remains â‰¥80% with Slack paths included).

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-22 | 0.1 | Initial draft defining Slack integration scope | Sarah (Product Owner) |
| 2025-10-22 | 0.2 | Corrected scope: webhook-only delivery, actual config file references, booking integration context | Sarah (Product Owner) |

---

## Definition of Done

- [x] Functional requirements met (AC 1-6 fully implemented)
- [x] Integration requirements verified (Slack enabled/disabled flows tested)
- [x] Regression tests updated and passing (24/24 Slack tests passing)
- [x] Code follows existing dependency-injection patterns (ActionContext + ActionServicesBundle)
- [x] Documentation updated (configuration + operator guide in docs/testing/slack-integration.md)
- [x] Rollback plan validated (toggle SLACK_ENABLED=false disables all Slack delivery)

---

## Risk & Compatibility

- **Primary Risk:** Misconfigured Slack credentials could block rule execution or expose secrets in logs.  
- **Mitigation:** Implement config validation with clear error messages, mask secrets in logs, default to graceful skip when disabled.  
- **Rollback:** Disable Slack via configuration flag or remove webhook secret; no code rollback required.

**Compatibility Verification**
- [x] No breaking changes to existing rule engine APIs  
- [x] Database schema untouched  
- [x] UI unaffected (backend-only change)  
- [x] Performance impact negligible (network call behind feature flag)

---

## Validation Checklist

**Scope Validation**
- [x] Work fits in one focused development session (single executor + config plumbing)  
- [x] Integration approach mirrors established patterns  
- [x] No new architectural decisions required  
- [x] Rollback via config toggle is straightforward

**Clarity Check**
- [x] Requirements are specific and testable  
- [x] Integration points (actions, settings, docs) are explicit  
- [x] Acceptance criteria reference concrete files/tests  
- [x] Success and rollback conditions defined
