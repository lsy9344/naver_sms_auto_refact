# Story 3.2: Implement Condition Evaluators

**Status:** Draft

---

## Quick Project Assessment

**Current System Context**
- [x] Relevant existing functionality identified (`original_code/lambda_function.py:126-210`, `original_code/lambda_function.py:176-205`)
- [x] Technology stack for this area noted (Python 3.11 containerized Lambda, boto3 DynamoDB client, YAML-configured rule engine)
- [x] Integration point(s) clearly understood (RuleEngine context builder, DynamoDB `sms_table`, bookings pulled from Naver Partner API)
- [x] Existing patterns for similar work identified (pure functions registered via `RuleEngine.register_condition`, architecture guidance `docs/brownfield-architecture.md:910-1140`)

**Change Scope**
- [x] Specific change clearly defined (`src/rules/conditions.py` module providing reusable evaluators)
- [x] Impact boundaries identified (condition registry wiring in `src/rules/engine.py` and configuration in `config/rules.yaml`)
- [x] Success criteria established (boolean outcomes match legacy logic across regression fixtures)

---

## Story

**As a** developer,
**I want** to implement dedicated condition evaluator functions that mirror the legacy booking logic,
**so that** the rule engine can make the exact same decisions that the monolithic Lambda currently performs.

---

## Story Context

**Existing System Integration:**
- Integrates with: `RuleEngine.process_booking` context builder and DynamoDB booking state (`src/database/dynamodb_client.py`)
- Technology: Python 3.11 AWS Lambda container, boto3 DynamoDB client, dataclass-based booking models
- Follows pattern: Functional registries described in `docs/brownfield-architecture.md:1070-1145`
- Touch points: `src/rules/engine.py`, `src/rules/__init__.py`, `config/rules.yaml`, `src/domain/booking.py`

---

## Acceptance Criteria

**Functional Requirements:**
1. `booking_not_in_db(context)` returns `True` only when `context['db_record']` is `None`, matching the legacy new-booking branch (`original_code/lambda_function.py:135-154`) and returns `False` otherwise.
2. `time_before_booking(context, hours)` reproduces the legacy window check (`reserve_at - timedelta(hours=2) <= now < reserve_at`) for any integer hour offset, using timezone-aware datetimes from the context and short-circuiting on missing inputs (`original_code/lambda_function.py:137-169`).
3. `flag_not_set(context, flag)` evaluates to `True` when the DynamoDB record is missing the flag or the value is explicitly `False`, and to `False` when the flag is `True`, mirroring confirmation/reminder/option guard rails (`original_code/lambda_function.py:160-194`).
4. `current_hour(context, hour)` compares the 24-hour integer against `context['current_time']` using the project timezone, replicating the option SMS gating at 20:00 (`original_code/lambda_function.py:176-186`).
5. `booking_status(context, status)` reads the booking status supplied by the Naver API and supports the `RC03` and `RC08` cases used today, returning `False` on missing data (`docs/brownfield-architecture.md:1000-1035`).
6. `has_option_keyword(context)` inspects the booking’s option names against the configured keyword list and matches the legacy nested-loop behavior with early exit once a keyword is detected (`original_code/lambda_function.py:255-366`).

**Integration Requirements:**
7. Condition evaluators are registered with the rule engine via a `register_conditions(engine: RuleEngine, settings: Settings)` helper and consumed by `config/rules.yaml` without additional code changes.
8. Regression fixtures drawn from the current Lambda outputs show identical boolean decisions between the new evaluators and the legacy helper functions for new bookings, two-hour reminders, and 8 PM option messages.
9. Rule engine context objects remain immutable during evaluation—no condition mutates `context` or external state, preserving deterministic behavior for subsequent evaluators.

**Quality Requirements:**
10. Unit tests cover success, failure, and edge cases for each evaluator (`tests/rules/test_conditions.py`) with >85% coverage for the module.
11. Developer documentation (docstrings or `docs/rules/README.md`) explains expected context keys and references the legacy source lines for future maintainers.
12. Comparison harness (e.g., `tests/regression/test_condition_parity.py`) validates parity against recorded fixtures from the monolith before marking the story done.

---

## Technical Notes

- **Integration Approach:** Introduce `src/rules/conditions.py` exporting pure functions plus a registry helper invoked during Lambda startup to register the evaluators with `RuleEngine`.
- **Existing Pattern Reference:** Preserve semantics from `original_code/lambda_function.py` branches and the architecture blueprint in `docs/brownfield-architecture.md:1070-1145`.
- **Key Constraints:** Evaluators must tolerate missing context keys without raising; datetimes use project timezone rules; keyword comparisons remain case-sensitive to match production behavior.

---

## Definition of Done

- [ ] Functional requirements met
- [ ] Integration requirements verified
- [ ] Existing functionality regression tested
- [ ] Code follows existing patterns and standards
- [ ] Tests pass (existing and new)
- [ ] Documentation updated if applicable

---

## Risk and Compatibility Check

- **Primary Risk:** Diverging condition logic could send duplicate or missed SMS messages for bookings.
- **Mitigation:** Use fixture-based parity tests comparing legacy helper outputs before deployment and peer review the math around datetime windows.
- **Rollback:** Replace the condition registry wiring with the legacy shim (retain current `RuleEngine` stubs) and redeploy the previous container image.

**Compatibility Verification**
- [x] No breaking changes to existing APIs (RuleEngine signature unchanged)
- [x] Database access remains read-only (conditions do not write to DynamoDB)
- [x] UI behavior unchanged (rule decisions stay identical to legacy flow)
- [x] Performance impact negligible (pure in-memory evaluations)

---

## Validation Checklist

- [x] Story can be completed in one development session
- [x] Integration approach is straightforward
- [x] Follows existing patterns exactly
- [x] No design or architecture work required
- [x] Story requirements are unambiguous
- [x] Integration points are clearly specified
- [x] Success criteria are testable
- [x] Rollback approach is simple

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-18 | 1.0 | Story created from Epic 3 | Sarah (PO) |

