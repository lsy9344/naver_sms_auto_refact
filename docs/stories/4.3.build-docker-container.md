# Story 4.3: Build Docker Container

**Status:** Approved

---

## Quick Project Assessment

**Current System Context**
- [x] Epic 4 drives integration of the refactored modules into a cohesive Lambda deployment and highlights containerization as critical for Python 3.11 parity (`docs/epics/epic-4-integration-testing.md:1-120`).
- [x] Target source layout separates application code under `src/` with dedicated auth, API, rules, notifications, config, and utils packages that must be packaged into the container (`docs/brownfield-architecture.md:935-959`).
- [x] Legacy Lambda currently relies on Lambda Layers with brittle Chrome/ChromeDriver management, motivating an ECR-based container migration (`docs/brownfield-architecture.md:180-217`).

**Change Scope**
- [x] Author the production Dockerfile based on the Lambda Python 3.11 base image, install Chrome/ChromeDriver, set binary paths, install dependencies, and copy application assets (`docs/brownfield-architecture.md:1361-1405`).
- [x] Validate the container with local Lambda Runtime Interface Emulator (RIE) runs and document build/run commands for developers and CI (`docs/brownfield-architecture.md:1494-1524`).
- [x] Outline tagging and push workflow to Amazon ECR so deployment automation can re-use the image packaging strategy (`docs/brownfield-architecture.md:1363-1372`).

---

## Story

**As a** DevOps engineer,  
**I want** to build a Lambda-compatible Docker container for the refactored automation service,  
**so that** we can package all runtime dependencies consistently and deploy via ECR without Lambda Layer constraints.

---

## Story Context

- Container must bundle Selenium prerequisites (Chrome + ChromeDriver) alongside Python dependencies and refactored modules to ensure runtime parity with production (`docs/brownfield-architecture.md:1361-1405`).
- The image becomes the deployment artifact for Epic 5, so build outputs, tags, and documentation must align with the upcoming ECR push pipeline (`docs/epics/epic-4-integration-testing.md:53-115`, `docs/brownfield-architecture.md:1363-1372`).
- Local developers will rely on Lambda RIE workflows with `.env` configuration to exercise the container before comparison testing executes (`docs/brownfield-architecture.md:1494-1524`).

---

## Acceptance Criteria

**Functional Requirements**
1. Dockerfile uses `public.ecr.aws/lambda/python:3.11` as the base image and installs Chrome/ChromeDriver with env vars `CHROME_BIN` and `CHROMEDRIVER_BIN` exported for Selenium (`docs/brownfield-architecture.md:1381-1395`).
2. Image build copies `requirements.txt`, installs dependencies with `pip --no-cache-dir`, and copies the entire `src/` tree plus supporting configuration required at runtime (`docs/brownfield-architecture.md:1397-1405`, `docs/epics/epic-4-integration-testing.md:84-112`).
3. Container entrypoint executes `main.lambda_handler`, matching the refactored Lambda handler contract defined for Epic 4 (`docs/brownfield-architecture.md:1401-1405`, `docs/epics/epic-4-integration-testing.md:27-82`).

**Integration Requirements**
4. `docker build -t naver-sms-automation .` succeeds locally and instructions for tagging/pushing to `{account}.dkr.ecr.{region}.amazonaws.com/naver-sms-automation` are documented for reuse (`docs/brownfield-architecture.md:1363-1372`).
5. Local run with Lambda RIE via `docker run --rm -p 9000:8080 --env-file .env naver-sms-automation:latest` executes without runtime errors and accepts sample invoke payloads (`docs/brownfield-architecture.md:1494-1524`).
6. Build artifacts, run commands, and environment variable expectations are captured in repo documentation (e.g., README snippet or new doc section) so developers can repeat the workflow (`docs/brownfield-architecture.md:1494-1524`, `docs/prd.md:610-624`).

**Quality Requirements**
7. Resulting image size remains under the 10GB gate set for Epic 4 and is noted during verification (`docs/epics/epic-4-integration-testing.md:88-115`).
8. Packaging process aligns with the GitHub Actions deployment plan (build, tag with SHA, push, update Lambda) so Release Engineering can integrate it in Epic 5 without rework (`docs/brownfield-architecture.md:1555-1593`).

---

## Tasks / Subtasks

- [ ] Task 1: Create production Dockerfile (AC: 1, 2, 3)
  - [ ] Base image `public.ecr.aws/lambda/python:3.11` selected with comment explaining rationale
  - [ ] Chrome/ChromeDriver installed with pinned download URIs and binaries exposed via env vars
  - [ ] `requirements.txt`, `src/`, and configuration assets copied into `$LAMBDA_TASK_ROOT`
  - [ ] `CMD ["main.lambda_handler"]` defined and verified

- [ ] Task 2: Validate container build and runtime (AC: 4, 5, 7)
  - [ ] Run `docker build -t naver-sms-automation .` and capture image size from `docker images`
  - [ ] Execute Lambda RIE command with `.env` file and confirm health check invoke succeeds
  - [ ] Document observed size (<10GB) and runtime output in `VALIDATION.md` or story notes

- [ ] Task 3: Document packaging & release workflow (AC: 4, 6, 8)
  - [ ] Add developer guide for build/run/tag/push commands (README or new doc under `docs/infra/`)
  - [ ] Ensure GitHub Actions deployment plan references the same image tag pattern
  - [ ] Note environment variables and secrets needed for local runs and CI publishing

---

## Dependency Checkpoints

- [ ] Story 4.1 (Create main.py Lambda Handler) approved with handler exposing `main.lambda_handler` consistent with container entrypoint expectations (`docs/epics/epic-4-integration-testing.md:24-72`).
- [ ] Story 4.2 (Implement Comparison Testing Framework) ready so container can be exercised by parity tests after build (`docs/epics/epic-4-integration-testing.md:73-112`).

---

## Dev Notes

### Source Tree Information
- `Dockerfile` to live at project root beside `requirements.txt` following target structure that organizes refactored modules under `src/` and configs under `config/` (`docs/brownfield-architecture.md:935-959`, `docs/brownfield-architecture.md:1397-1404`).
- Runtime bundles must include `src/main.py`, auth/api/rules modules, config loader assets, and notification clients to ensure handler execution succeeds post-build (`docs/brownfield-architecture.md:935-959`, `docs/epics/epic-4-integration-testing.md:27-112`).

### Container Build Requirements
- Base image: `public.ecr.aws/lambda/python:3.11`, chosen for Lambda compatibility and Python 3.11 support (`docs/brownfield-architecture.md:1383-1385`).
- Install Chrome and ChromeDriver using official chrome-for-testing archives, clean up download artifacts, and expose `CHROME_BIN`/`CHROMEDRIVER_BIN` env variables for Selenium to discover binaries (`docs/brownfield-architecture.md:1385-1395`).
- Use `pip install --no-cache-dir -r requirements.txt` within the image to avoid cached wheels and keep size minimized (`docs/brownfield-architecture.md:1397-1399`).
- Copy `src/` (and config assets if stored outside) to `$LAMBDA_TASK_ROOT` so Lambda runtime finds modules without modifying `PYTHONPATH` (`docs/brownfield-architecture.md:1401-1404`).

### Build & Publish Workflow
- Standard workflow: `docker build -t naver-sms-automation .`, tag with AWS registry URL, push to ECR, then update Lambda to consume the latest tag (`docs/brownfield-architecture.md:1363-1372`).
- Deployment automation via GitHub Actions already scripts login, build, tag (commit SHA + latest), and Lambda update; align local instructions with this sequence for consistency (`docs/brownfield-architecture.md:1555-1593`).
- Capture image digest and tag details in deployment notes so Epic 5 can reuse without recalculating steps (`docs/brownfield-architecture.md:1363-1372`).

### Local Execution & Testing
- Follow `.env`-driven Lambda RIE workflow: build image, run `docker run --rm -p 9000:8080 --env-file .env naver-sms-automation:latest`, then invoke via `curl` to `http://localhost:9000/...` for smoke verification (`docs/brownfield-architecture.md:1494-1524`).
- Document expected environment variables (AWS credentials, Secrets Manager references) and caution developers that real SMS sends should be disabled or mocked during local runs (`docs/brownfield-architecture.md:1494-1524`).

### Config & Secrets Handling
- Ensure container bundles configuration files loaded by `Settings.load()` (e.g., `config/settings.yaml`, rule definitions) and confirm `.env` values map to Secrets Manager/Parameter Store usage defined earlier in the architecture (`docs/brownfield-architecture.md:935-959`, `docs/brownfield-architecture.md:1167-1189`).
- Highlight AWS credentials requirements and recommended use of IAM profiles or temporary credentials when running locally (`docs/brownfield-architecture.md:1496-1519`).

### Testing Standards
- Validate container build/run as part of regression evidence and log commands/output in `VALIDATION.md` to support QA gate (`docs/epics/epic-4-integration-testing.md:87-115`, `docs/brownfield-architecture.md:1363-1372`).
- When parity framework (Story 4.2) is available, execute comparison tests against the containerized handler to ensure zero regressions before deployment (`docs/epics/epic-4-integration-testing.md:73-115`).
- Integrate container smoke tests into CI once GitHub Actions job is updated, mirroring manual local steps (`docs/brownfield-architecture.md:1555-1593`).

### Testing

**Local Validation Commands**
- `docker build -t naver-sms-automation .`
- `docker run --rm -p 9000:8080 --env-file .env naver-sms-automation:latest`
- `curl -XPOST "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"smoke": true}'`
- `docker images naver-sms-automation`

**CI Alignment**
- Reuse commands within GitHub Actions so build/tag/push steps stay deterministic and traceable (`docs/brownfield-architecture.md:1555-1593`).

---

## Technical Notes

- Containerization removes Lambda Layer limitations and accelerates Python upgrades, addressing legacy maintenance pain points (`docs/brownfield-architecture.md:180-217`).
- Ensure Dockerfile remains image-layer efficient (combine RUN instructions where possible, clean temporary archives) to stay comfortably below the 10GB limit (`docs/epics/epic-4-integration-testing.md:88-115`, `docs/brownfield-architecture.md:1385-1391`).
- Document version pinning for Chrome/ChromeDriver to avoid silent mismatches during AWS patch cycles (`docs/epics/epic-4-integration-testing.md:84-112`).

---

## Definition of Done

- [ ] Dockerfile committed and reviewed with references to architecture requirements.
- [ ] Local build and Lambda RIE smoke test evidence captured (commands, logs, image size).
- [ ] Documentation updated so developers and CI know how to build/tag/push the image.
- [ ] Acceptance Criteria 1-8 satisfied with supporting notes in `VALIDATION.md` or story comments.

---

## Risk and Compatibility Check

- **Primary Risk:** Chrome/ChromeDriver version drift causing Selenium failures inside Lambda.
  - **Mitigation:** Pin versions in Dockerfile, add health check to validate browser launches during build/test.
- **Compatibility Verification**
  - [ ] Confirms compatibility with Lambda container runtime
  - [ ] Works with Secrets Manager/Parameter Store loading strategy
  - [ ] Supports upcoming integration tests and deployment automation

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-22 | 1.0 | Story drafted from Epic 4 containerization requirements | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
- _TBD_

### Debug Log References
- _TBD_

### Completion Notes List
1. _TBD_

### File List
- _TBD_

## QA Results
- _TBD_
