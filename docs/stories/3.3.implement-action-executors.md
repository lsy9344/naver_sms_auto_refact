# Story 3.3: Implement Action Executors

**Status:** Approved

---

## Quick Project Assessment

**Current System Context**
- [x] Legacy actions identified in `original_code/lambda_function.py:140-205, 439-446` and `original_code/sens_sms.py`.
- [x] Technology stack: Python 3.11 Lambda container, DynamoDB repositories (Story 2.3), SENS client (Story 2.2), configuration loader (Story 2.4).
- [x] Integration points: `RuleEngine.execute_rule`, notifications layer, DynamoDB repositories, Telegram/Slack notification services.
- [x] Existing patterns: Async-capable executors registered in rule engine (`docs/brownfield-architecture.md:1140-1165`).

**Change Scope**
- [x] Actions implemented in `src/rules/actions.py` using dependency injection for repositories/services.
- [x] Boundaries: interacts with SMS client, DynamoDB repositories, notification services; no direct HTTP calls elsewhere.
- [x] Success Criteria: parity with legacy side effects (SMS sent, DynamoDB updated, Telegram alerts) validated via regression harness.

---

## Story

**As a** developer,
**I want** to provide rule engine action executors that encapsulate all side effects,
**so that** declarative rules can trigger SMS sends, database updates, and notifications identical to the legacy system.

---

## Story Context

**Existing System Integration:**
- Integrates with: `RuleEngine.execute_rule`, registries in `src/rules/__init__.py`, DynamoDB repositories, notification services.
- Technology: Python async-capable functions (awaited or run via event loop), boto3 DynamoDB client, SENS REST API, Telegram/Slack webhooks.
- Follows pattern: Architecture guidance for action executors (`docs/brownfield-architecture.md:1140-1165`).
- Touch points: `config/rules.yaml`, `src/rules/engine.py`, `src/notifications/sms_service.py`, `src/database/dynamodb_client.py`, `src/notifications/telegram_service.py`, `src/notifications/slack_service.py`.

---

## Acceptance Criteria

**Functional Requirements**
1. Implement executor functions (`send_sms`, `create_db_record`, `update_flag`, `send_telegram`, `send_slack`, `log_event`) in `src/rules/actions.py` that mirror legacy logic, consuming dependencies from the services/repositories created in Epic 2 and masking sensitive data in logs.
2. `send_sms` delegates to the SENS client with parameters derived from rule context (template, store-specific flag) and logs success/failure; behavior matches `send_sms` calls in `original_code/lambda_function.py`.
3. `create_db_record` inserts booking records into DynamoDB with the exact schema used in the legacy flow, including `confirm_sms`, `remind_sms`, and `option_sms` flags, using the BookingRepository.
4. `update_flag` updates a single DynamoDB boolean flag and returns the updated record or success indicator consistent with legacy `update_item`; handles idempotency by short-circuiting when flag already set.
5. `send_telegram` posts messages via Telegram service with identical payload structure (from Story 2.2/2.3 extraction), supporting templated messages from rules; `send_slack` integrates with Slack webhook configuration (no-op if Slack disabled).
6. `log_event` writes structured log entries with metadata (`rule`, `action`, `booking_id`, `status`, `message`) that align with CloudWatch metric filters (Story 1.4).

**Integration Requirements**
7. Action registry helper (`register_actions(engine: RuleEngine, services: ActionServicesBundle)`) registers all executors and is invoked during application bootstrap.
8. Executors accept a shared `ActionContext` dataclass containing booking, settings, repositories, and logger references; unit tests verify immutability and safe reuse.
9. Error handling: executor exceptions are wrapped in `ActionExecutionError` with context; the rule engine logs the failure and continues evaluating remaining actions per AC from Story 3.1.

**Quality Requirements**
10. Unit tests (`tests/rules/test_actions.py`) cover success, failure, and edge cases for each executor using mocks/stubs; asynchronous behavior tested via pytest-asyncio.
11. Integration tests (`tests/integration/test_rule_actions.py`) run against local DynamoDB and stubbed notification services to ensure side effects (DB writes, SMS call, notifications) execute end-to-end.
12. Documentation (`docs/rules/actions.md`) explains each executor, required context keys, and how to add new actions; validation evidence (test results, regression comparisons) appended to `VALIDATION.md`.

---

## Tasks / Subtasks

- [ ] Implement action executor module core (AC 1)
  - [ ] Create `src/rules/actions.py` with pure function exports
  - [ ] Define `ActionContext` dataclass (see Dev Notes below)
  - [ ] Define `ActionServicesBundle` dataclass (see Dev Notes below)
  - [ ] Ensure all executors accept context parameter and perform dependency injection

- [ ] Implement SMS action executor (AC 2)
  - [ ] Create `send_sms(context, template, store_specific=False)` function
  - [ ] Delegate to SENS client via `context.sms_service`
  - [ ] Handle template parameter mapping (confirmation, guide, event templates)
  - [ ] Log success/failure with redacted sensitive data
  - [ ] Match legacy behavior at `original_code/lambda_function.py:152, 164, 191`

- [ ] Implement database action executors (AC 3, 4)
  - [ ] Create `create_db_record(context, booking_data)` function
    - [ ] Use `context.db_repo` (BookingRepository from Story 2.3)
    - [ ] Insert with booking schema: booking_num, phone, name, booking_time, confirm_sms, remind_sms, option_sms, option_time
    - [ ] Match legacy insert at `original_code/lambda_function.py:150`
  - [ ] Create `update_flag(context, flag_name, flag_value)` function
    - [ ] Update single boolean flag on DynamoDB record
    - [ ] Handle idempotency (short-circuit if already set)
    - [ ] Match legacy updates at `original_code/lambda_function.py:163, 167, 190`
    - [ ] Return updated record or success indicator

- [ ] Implement notification action executors (AC 5)
  - [ ] Create `send_telegram(context, message, template_params=None)` function
    - [ ] Use `context.telegram_service` for webhook calls
    - [ ] Support template variable substitution (e.g., {{booking.phone}})
    - [ ] Match legacy Telegram payload at `original_code/lambda_function.py:439-446`
  - [ ] Create `send_slack(context, message, template_params=None)` function
    - [ ] Use `context.slack_service` (check if enabled via config)
    - [ ] No-op if Slack is disabled in settings
    - [ ] Support same template variable substitution as Telegram

- [ ] Implement logging action executor (AC 6)
  - [ ] Create `log_event(context, rule_name, action_name, status, message)` function
    - [ ] Write structured logs with metadata: rule, action, booking_id, status, message
    - [ ] Use `context.logger` for output
    - [ ] Ensure format aligns with CloudWatch metric filters (Story 1.4)
    - [ ] Include booking_id for traceability

- [ ] Implement registry helper and error handling (AC 7, 9)
  - [ ] Create `register_actions(engine: RuleEngine, services: ActionServicesBundle)` function
    - [ ] Register all 6 executors with RuleEngine
    - [ ] Store executor references in engine registry
  - [ ] Define `ActionExecutionError` exception class
    - [ ] Include context information (executor name, booking_id, error details)
    - [ ] Wrap executor exceptions with context
    - [ ] Ensure rule engine can catch and log failures

- [ ] Write comprehensive unit tests (AC 10)
  - [ ] Create `tests/rules/test_actions.py`
  - [ ] Mock all services (SMS, Telegram, Slack, DynamoDB)
  - [ ] Test success cases for each executor
  - [ ] Test failure cases and error wrapping
  - [ ] Test idempotency for `update_flag`
  - [ ] Test immutability of ActionContext
  - [ ] Use pytest-asyncio if any async behavior needed

- [ ] Create integration tests (AC 11)
  - [ ] Create `tests/integration/test_rule_actions.py`
  - [ ] Use local DynamoDB or moto for DynamoDB testing
  - [ ] Stub notification services
  - [ ] Test end-to-end action execution
  - [ ] Verify DB writes, SMS calls, notifications all execute
  - [ ] Test error handling and rule continuation

- [ ] Create developer documentation (AC 12)
  - [ ] Create `docs/rules/actions.md`
  - [ ] Document each executor function signature and parameters
  - [ ] Explain ActionContext and ActionServicesBundle
  - [ ] Provide examples of rule YAML using each action
  - [ ] Explain how to add new actions to the executor system
  - [ ] Document error handling and logging

- [ ] Verify immutability and safety (AC 8)
  - [ ] Add unit tests verifying ActionContext is not mutated
  - [ ] Verify safe concurrent reuse of context
  - [ ] Document immutability contracts in docstrings

---

## Dev Notes

### ActionContext Dataclass Structure

All action executors receive a shared `ActionContext` object containing:

```python
@dataclass
class ActionContext:
    """
    Immutable context passed to all action executors.
    Contains all dependencies needed for side effects.
    """
    booking: Booking                          # Current booking (from src/domain/booking.py)
    settings: Settings                        # Configuration (from src/config/settings.py)
    db_repo: BookingRepository               # DynamoDB repository for booking records
    sms_service: SmsService                  # SENS SMS client (from src/notifications/sms_service.py)
    telegram_service: TelegramService        # Telegram webhook client
    slack_service: SlackService              # Slack webhook client
    logger: logging.Logger                    # Structured logger with redaction
```

**Key Notes:**
- Context is immutable - no executor may modify it
- All services are injected, enabling unit testing via mocks
- Booking must be the current record being processed
- Settings provides timezone, feature flags, and configurations

### ActionServicesBundle Dataclass

The services bundle passed to `register_actions()`:

```python
@dataclass
class ActionServicesBundle:
    """
    Bundle of services needed by action executors.
    Passed to register_actions() during application bootstrap.
    """
    db_repo: BookingRepository               # DynamoDB operations
    sms_service: SmsService                  # SENS SMS API client
    telegram_service: TelegramService        # Telegram webhook (from Story 2.2)
    slack_service: SlackService              # Slack webhook (from Story 2.2)
    logger: logging.Logger                   # Application logger with redaction
```

### DynamoDB Booking Schema Reference

Refer to `src/domain/booking.py` (Booking dataclass):
- `booking_num`: str (composite key "{biz_id}_{book_id}")
- `phone`: str (sort key, customer phone)
- `name`: str (customer name)
- `booking_time`: str ("YYYY-MM-DD HH:MM:SS" format)
- `confirm_sms`: bool (flag = confirmation SMS sent)
- `remind_sms`: bool (flag = 2-hour reminder SMS sent)
- `option_sms`: bool (flag = event/option SMS sent)
- `option_time`: str (reserved field for future use)
- `extra_fields`: Dict[str, Any] (dynamic expansion support)

**AC 3 Context:** `create_db_record` must insert using this exact schema from Booking model.

### Service Dependencies from Epic 2

From Story 2.2 (Extract SENS SMS Module):
- `SmsService` - Interface for sending SMS via SENS REST API
- Methods: `send_sms(phone, template_id, store_id=None)` → returns success/failure

From Story 2.3 (Extract DynamoDB Operations):
- `BookingRepository` - DynamoDB repository for bookings
- Methods: `create(booking)`, `update_flag(booking_id, flag_name, value)`, `get(booking_id)`

From Story 2.2 (Telegram/Slack extraction context):
- `TelegramService` - Webhook client for Telegram Bot API
- `SlackService` - Webhook client for Slack APIs (may be disabled)

From Story 2.4 (Configuration Loader):
- Slack enable/disable flag: `settings.slack_enabled` or similar from config

### Error Handling Pattern

Define `ActionExecutionError` exception:

```python
@dataclass
class ActionExecutionError(Exception):
    """
    Wraps executor exceptions with context for rule engine handling.
    """
    executor_name: str                       # Which executor failed (send_sms, create_db_record, etc.)
    booking_id: str                          # Which booking triggered the error
    original_error: Exception                # Original exception from executor
    context_data: Dict[str, Any]             # Additional context (rule name, etc.)
    
    def __str__(self) -> str:
        return (f"Action '{self.executor_name}' failed for booking {self.booking_id}: "
                f"{str(self.original_error)}")
```

**Usage Pattern in Executors:**
```python
def send_sms(context: ActionContext, template: str, store_specific: bool = False):
    try:
        # SMS sending logic
        result = context.sms_service.send_sms(...)
    except Exception as e:
        raise ActionExecutionError(
            executor_name="send_sms",
            booking_id=context.booking.booking_num,
            original_error=e,
            context_data={"template": template, "store_specific": store_specific}
        )
```

### Async Execution Model

**Decision:** Executors are synchronous functions returning results (not async def)
- Rule engine calls executors sequentially
- If async needed in future, wrap executor calls with async context manager
- Current implementation: all I/O (boto3, requests) uses sync/blocking calls
- Lambda timeout sufficient for sequential execution

**Future:** If async executors needed in Epic 4+, use:
```python
async def send_sms_async(context, template):
    # Async implementation
    pass

# Run in event loop
asyncio.run(send_sms_async(context, template))
```

### Relevant Source Tree

```
src/
├── rules/
│   ├── __init__.py                        # Exports register_conditions, register_actions
│   ├── engine.py                          # RuleEngine class with registries
│   ├── conditions.py                      # Condition evaluators (Story 3.2)
│   ├── actions.py                         # [THIS STORY] Action executors
│   └── exceptions.py                      # ActionExecutionError, ActionContext, ActionServicesBundle
├── notifications/
│   ├── sms_service.py                     # SmsService interface (Story 2.2)
│   ├── telegram_service.py                # TelegramService from extraction (Story 2.2)
│   └── slack_service.py                   # SlackService from extraction (Story 2.2)
├── database/
│   ├── dynamodb_client.py                 # DynamoDB client
│   └── repositories.py                    # BookingRepository interface (Story 2.3)
├── domain/
│   └── booking.py                         # Booking dataclass model
├── config/
│   └── settings.py                        # Configuration loader (Story 2.4)
config/
└── rules.yaml                             # Rule definitions (consumed by Story 3.4)
```

### Legacy Code Reference for Verification

Use these line ranges to verify action parity:
- `original_code/lambda_function.py:140-205` - Main action logic
- `original_code/lambda_function.py:150` - create_db_record pattern (put_item)
- `original_code/lambda_function.py:152, 164, 191` - send_sms calls with different templates
- `original_code/lambda_function.py:163, 167, 190` - update_item (flag updates)
- `original_code/lambda_function.py:439-446` - Telegram webhook calls
- `original_code/sens_sms.py` - SMS template mappings and SENS client usage

### Testing Standards

From architecture and existing patterns:
- **Test Framework:** pytest
- **Async Testing:** pytest-asyncio for async functions
- **Unit Test Location:** `tests/rules/test_actions.py`
- **Integration Test Location:** `tests/integration/test_rule_actions.py`
- **Mocking:** Use `unittest.mock` or `pytest-mock` for services
- **DynamoDB Testing:** Use `moto` for local DynamoDB or create fixtures
- **Fixtures:** Use conftest.py for shared ActionContext, test bookings, mock services
- **Coverage Requirement:** No explicit requirement in AC, but aim for >85%

---

## Technical Notes

- **Integration Approach:** Use dependency bundle (repositories, sms client, notification services) passed to registry; executors remain pure functions aside from calling injected services.
- **Existing Pattern Reference:** `docs/brownfield-architecture.md:394-465` mapping of legacy actions to new executors.
- **Key Constraints:** Preserve legacy payloads for SENS/Telegram; ensure DynamoDB schema unchanged; maintain logging format for metrics.

---

## Definition of Done

- [ ] Functional requirements satisfied
- [ ] Integration requirements verified
- [ ] Tests and documentation updated
- [ ] Validation evidence recorded

---

## Risk and Compatibility Check

- **Primary Risk:** Divergent side effects (duplicate SMS, missed updates).  
  **Mitigation:** Regression comparison suite, staging dry runs before production cutover.
- **Rollback:** Switch rule engine actions back to legacy helper calls via feature flag.

**Compatibility Verification**
- [x] Works with rule engine core and condition evaluators  
- [x] Aligns with configuration loader and services from Epic 2  
- [x] Supports future actions (Slack extension)

---

## Validation Checklist

- [x] Story can be completed in one development session
- [x] Integration approach is straightforward
- [x] Follows existing patterns exactly
- [x] No design or architecture work required
- [x] Story requirements are unambiguous
- [x] Integration points are clearly specified
- [x] Success criteria are testable
- [x] Rollback approach is simple

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-19 | 1.1 | Added Tasks/Subtasks, Dev Notes with ActionContext/ActionServicesBundle, error handling pattern, and service dependencies | Sarah (PO) |
| 2025-10-18 | 1.0 | Story created from Epic 3 requirements | Sarah (PO) |
