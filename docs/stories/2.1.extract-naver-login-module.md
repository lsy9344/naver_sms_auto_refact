# Story 2.1: Extract Naver Login Module

**Status:** Draft

---

## Story

**As a** developer,
**I want** to extract the Naver login mechanism into a dedicated module,
**so that** it can be tested independently while preserving 100% of the current working logic.

**⚠️ CRITICAL:** This story has the HIGHEST RISK. Naver login must work identically. Zero modifications to login logic allowed.

---

## Acceptance Criteria

1. Naver login code (lambda_function.py:260-301) extracted to `src/auth/naver_login.py` **EXACTLY AS-IS**
2. Chrome options configuration (lambda_function.py:229-248) extracted **EXACTLY AS-IS**
3. Login works with cached cookies (same cookie reuse strategy)
4. Login falls back to fresh Selenium login on cookie expiry
5. Cookies saved to DynamoDB session table (same as before)
6. JavaScript credential injection preserved exactly (lines 274-276)
7. Random delays preserved exactly (lines 275-279)
8. Cookie validation via URL check preserved (line 298)
9. Recursive retry on failure preserved (line 300)
10. Unit tests pass (with mocked Selenium)
11. Integration tests pass (with real Naver login)

---

## Tasks / Subtasks

- [ ] Create `src/auth/naver_login.py` module (AC: 1, 2)
  - [ ] Copy lines 229-301 from lambda_function.py EXACTLY
  - [ ] Create `NaverAuthenticator` class
  - [ ] Preserve all variable names, timing, logic
  - [ ] **DO NOT REFACTOR OR "IMPROVE" THE CODE**

- [ ] Create unit tests with mocked Selenium (AC: 10)
  - [ ] Test cookie login path (cached cookies work)
  - [ ] Test fresh login path (no cookies)
  - [ ] Test retry on cookie expiry
  - [ ] Mock Selenium WebDriver

- [ ] Create integration tests with real Naver (AC: 11)
  - [ ] Test with real Naver credentials (test account)
  - [ ] Test cookie caching to DynamoDB
  - [ ] Test cookie reuse
  - [ ] Test fresh login when cookies expire

- [ ] Validate preservation (AC: 3-9)
  - [ ] Compare HTTP requests (headers, timing)
  - [ ] Compare cookie format
  - [ ] Compare DynamoDB session record
  - [ ] Character-by-character code comparison

- [ ] Integration with main handler
  - [ ] Update main.py to use NaverAuthenticator
  - [ ] Pass credentials from Secrets Manager
  - [ ] Verify session management works

---

## Dev Notes

### ⚠️ CRITICAL PRESERVATION REQUIREMENTS

**THIS IS THE MOST CRITICAL CODE IN THE SYSTEM.**

The Naver login mechanism took significant effort to develop and works reliably in production. Cookie reuse strategy minimizes Selenium overhead and bot detection risk.

**DO NOT:**
- Change variable names
- "Improve" or "modernize" the code
- Change timing or delays
- Modify the JavaScript injection
- Alter the cookie validation logic
- Remove print statements (convert to logging but preserve timing)

**PRESERVE 100%:**
- JavaScript credential injection (lines 274-276)
- Random delays with `uniform()` (lines 275-279) - mimics human behavior
- Cookie validation via URL check (line 298) - detects login failure
- Recursive retry (line 300) - automatically recovers from failures
- Chrome options (lines 229-248) - specific to Lambda environment

### Code to Extract (DO NOT MODIFY)

**From lambda_function.py:229-248 (Chrome Options):**
```python
chrome_options = Options()
chrome_options.binary_location = '/opt/chrome/chrome'
chrome_options.add_argument('--headless')
chrome_options.add_argument('--no-sandbox')
chrome_options.add_argument('--disable-dev-shm-usage')
chrome_options.add_argument('--disable-gpu')
chrome_options.add_argument('--disable-dev-tools')
chrome_options.add_argument('--no-zygote')
chrome_options.add_argument('--single-process')
chrome_options.add_argument('--user-data-dir=/tmp/user-data')
chrome_options.add_argument('--data-path=/tmp/data-path')
chrome_options.add_argument('--homedir=/tmp')
chrome_options.add_argument('--disk-cache-dir=/tmp/cache-dir')
chrome_options.add_argument("user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36")

service = Service(executable_path='/opt/chromedriver')

driver = webdriver.Chrome(service=service, options=chrome_options)
driver.get('https://new.smartplace.naver.com/')
```

**From lambda_function.py:260-301 (Login Function):**
```python
def login(cookies):
    if not cookies:
        # Fresh login - lines 262-292
        driver.get('https://nid.naver.com/nidlogin.login')
        time.sleep(uniform(2,4))

        # JavaScript injection for credentials
        driver.execute_script(f"document.getElementsByName('id')[0].value='{userid}'")
        time.sleep(uniform(0.7,1.3))
        driver.execute_script(f"document.getElementsByName('pw')[0].value='{userpw}'")
        time.sleep(uniform(0.7,1.3))

        # Submit and wait
        driver.find_element(By.ID, 'log.login').click()
        time.sleep(uniform(2.5,5))

        # Navigate and save cookies
        driver.get('https://new.smartplace.naver.com/')
        time.sleep(uniform(2,4))
        cookies = driver.get_cookies()

        session_cookie = json.dumps(cookies)
        dynamodb_session.put_item(Item={'id': '1', 'cookies': session_cookie})

        return cookies
    else:
        # Cookie reuse - lines 293-301
        for cookie in cookies:
            driver.add_cookie(cookie)

        driver.get('https://new.smartplace.naver.com/profile')
        time.sleep(uniform(1,2.5))

        if 'login' in driver.current_url:
            # Cookie expired, retry fresh login
            return login(None)
        else:
            return cookies
```

### Module Structure

**src/auth/naver_login.py:**
```python
import time
from random import uniform
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
import json

class NaverAuthenticator:
    """
    Handles Naver platform authentication using Selenium.

    CRITICAL: This code is preserved exactly from the original
    lambda_function.py (lines 229-301). Do not modify the login
    logic as it is sensitive to bot detection and works reliably.
    """

    def __init__(self, username: str, password: str, session_manager):
        self.username = username
        self.password = password
        self.session_manager = session_manager
        self.driver = None

    def setup_driver(self):
        """
        Setup Chrome WebDriver with Lambda-specific options.
        EXACT COPY: lambda_function.py:229-248
        """
        # EXACT CODE FROM LINES 229-248
        # DO NOT MODIFY
        pass

    def login(self, cached_cookies=None):
        """
        Login to Naver using cached cookies or fresh Selenium login.
        EXACT COPY: lambda_function.py:260-301

        Args:
            cached_cookies: List of cookie dicts from DynamoDB or None

        Returns:
            List of cookie dicts (fresh or validated cached)
        """
        # EXACT CODE FROM LINES 260-301
        # DO NOT MODIFY
        pass

    def get_session(self):
        """
        Convert Selenium session to requests.Session for API calls.
        """
        # Copy cookies from driver to requests.Session
        pass
```

**Integration Point (main.py):**
```python
from auth.naver_login import NaverAuthenticator
from database.session_manager import SessionManager
from config.settings import Settings

def lambda_handler(event, context):
    settings = Settings.load()

    # Get cached cookies
    session_mgr = SessionManager(dynamodb_client)
    cached_cookies = session_mgr.get_cookies()

    # Authenticate
    authenticator = NaverAuthenticator(
        settings.naver_username,
        settings.naver_password,
        session_mgr
    )
    cookies = authenticator.login(cached_cookies)

    # Get requests.Session for API calls
    api_session = authenticator.get_session()

    # Continue with booking API...
```

### References
- **Architecture Doc:** Lines 469-506 (Naver Login Preservation Requirements)
- **Architecture Doc:** Lines 1210-1230 (Refactoring Approach)
- **Original Code:** lambda_function.py:229-301
- **PRD:** Section 4.1 FR4 (Preservation Requirements - CRITICAL)

### Testing

**Unit Tests (tests/unit/test_naver_auth.py):**
```python
import pytest
from unittest.mock import Mock, patch, MagicMock
from auth.naver_login import NaverAuthenticator

@patch('auth.naver_login.webdriver.Chrome')
def test_fresh_login(mock_driver):
    """Test fresh login when no cached cookies"""
    # Setup mocks
    mock_driver_instance = MagicMock()
    mock_driver.return_value = mock_driver_instance
    mock_driver_instance.get_cookies.return_value = [{'name': 'NID_AUT', 'value': 'test'}]

    # Create authenticator
    session_mgr = Mock()
    auth = NaverAuthenticator('testuser', 'testpass', session_mgr)

    # Execute login with no cookies
    cookies = auth.login(cached_cookies=None)

    # Verify
    assert len(cookies) > 0
    assert cookies[0]['name'] == 'NID_AUT'
    assert mock_driver_instance.execute_script.call_count >= 2  # ID and PW injection

@patch('auth.naver_login.webdriver.Chrome')
def test_cookie_reuse(mock_driver):
    """Test login with valid cached cookies"""
    mock_driver_instance = MagicMock()
    mock_driver.return_value = mock_driver_instance
    mock_driver_instance.current_url = 'https://new.smartplace.naver.com/profile'

    session_mgr = Mock()
    auth = NaverAuthenticator('testuser', 'testpass', session_mgr)

    cached_cookies = [{'name': 'NID_AUT', 'value': 'cached'}]
    cookies = auth.login(cached_cookies=cached_cookies)

    # Should return cached cookies without fresh login
    assert cookies == cached_cookies
    assert mock_driver_instance.add_cookie.called

@patch('auth.naver_login.webdriver.Chrome')
def test_cookie_expiry_retry(mock_driver):
    """Test retry with fresh login when cached cookies expired"""
    mock_driver_instance = MagicMock()
    mock_driver.return_value = mock_driver_instance

    # First call: cookie expired (URL contains 'login')
    # Second call (recursive): fresh login succeeds
    mock_driver_instance.current_url = 'https://nid.naver.com/nidlogin.login'
    mock_driver_instance.get_cookies.return_value = [{'name': 'NID_AUT', 'value': 'fresh'}]

    session_mgr = Mock()
    auth = NaverAuthenticator('testuser', 'testpass', session_mgr)

    cached_cookies = [{'name': 'NID_AUT', 'value': 'expired'}]

    # Should detect expiry and retry
    # (Complex to mock recursion, may need refactoring for testability)
```

**Integration Tests (tests/integration/test_naver_auth_live.py):**
```python
import pytest
from auth.naver_login import NaverAuthenticator
from database.session_manager import SessionManager
import boto3

@pytest.mark.integration
@pytest.mark.skip(reason="Requires real Naver credentials and DynamoDB access")
def test_real_naver_login():
    """Test with real Naver credentials (use test account)"""
    # Setup
    dynamodb = boto3.resource('dynamodb', region_name='ap-northeast-2')
    session_mgr = SessionManager(dynamodb)

    auth = NaverAuthenticator(
        username='test_account_id',  # Use test account
        password='test_password',
        session_manager=session_mgr
    )

    # Test fresh login
    cookies = auth.login(cached_cookies=None)
    assert len(cookies) > 0
    assert any(c['name'] == 'NID_AUT' for c in cookies)

    # Test cookie reuse
    cookies2 = auth.login(cached_cookies=cookies)
    assert cookies2 == cookies  # Should reuse without fresh login
```

### Testing Standards

**Test File Location:**
- Unit: `tests/unit/test_naver_auth.py`
- Integration: `tests/integration/test_naver_auth_live.py`

**Coverage Requirement:** >80%

**Critical Tests:**
- Fresh login flow
- Cookie reuse flow
- Cookie expiry and retry
- DynamoDB session storage
- JavaScript injection timing
- Error handling

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-18 | 1.0 | Story created from Epic 2 | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used
(To be populated by dev agent)

### Debug Log References
(To be populated by dev agent)

### Completion Notes List
(To be populated by dev agent)

### File List
(To be populated by dev agent)

---

## QA Results
(To be populated by QA agent)
