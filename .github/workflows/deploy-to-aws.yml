name: Build, Test & Deploy to AWS

on:
  workflow_dispatch:
    inputs:
      reason:
        description: "Reason for manual deployment"
        required: false
        default: "Manual deployment"
        type: string
  push:
    branches:
      - main
    paths:
      - "src/**"
      - "config/**"
      - "Dockerfile"
      - "requirements.txt"
      - ".github/workflows/deploy-to-aws.yml"
  pull_request:
    branches:
      - main
    paths:
      - "src/**"
      - "config/**"
      - "Dockerfile"
      - "requirements.txt"

permissions:
  contents: write  # Required for pushing commits to repository
  id-token: write  # Required for AWS authentication
  actions: read    # Required for reading workflow artifacts

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY_NAME: naver-sms-automation
  LAMBDA_FUNCTION_NAME: naverplace_send_inform_v2
  AWS_ACCOUNT_ID: 654654307503

jobs:
  # ============================================================================
  # TESTING PHASE (FAST TRACK)
  # ============================================================================
  test:
    name: Fast Track Tests
    uses: ./.github/workflows/fast-tests.yml

  # ============================================================================
  # DOCKER BUILD & ECR PUSH PHASE
  # ============================================================================
  build-and-push:
    name: Build Docker Image & Push to ECR
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    env:
      BUILDKIT_OCI_MEDIA_TYPES: "0"
      DOCKER_DEFAULT_PLATFORM: linux/amd64
    outputs:
      image-uri: ${{ steps.build-outputs.outputs.image-uri }}
      image-tag: ${{ steps.build-outputs.outputs.image-tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image with cache
        id: image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          platforms: linux/amd64
          provenance: false
          sbom: false
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_NAME }}:${{ github.sha }}
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_NAME }}:latest
          cache-from: type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_NAME }}:buildcache
          cache-to: type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_NAME }}:buildcache,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1

      - name: Set outputs
        id: build-outputs
        run: |
          echo "image-uri=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_NAME }}:${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "image-tag=${{ github.sha }}" >> $GITHUB_OUTPUT
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}

      - name: Image scan results
        run: |
          echo "üì¶ Image pushed to ECR"
          echo "Registry: ${{ steps.login-ecr.outputs.registry }}"
          echo "Repository: $ECR_REPOSITORY_NAME"
          echo "Image URI: ${{ steps.build-outputs.outputs.image-uri }}"

  # ============================================================================
  # LAMBDA DEPLOYMENT PHASE
  # ============================================================================
  deploy-lambda:
    name: Deploy to Lambda
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update Lambda function code
        id: lambda-update
        run: |
          echo "üöÄ Updating Lambda function: $LAMBDA_FUNCTION_NAME"

          aws lambda update-function-code \
            --function-name $LAMBDA_FUNCTION_NAME \
            --image-uri ${{ needs.build-and-push.outputs.image-uri }} \
            --region ${{ env.AWS_REGION }} \
            --no-cli-pager > lambda-response.json

          # Extract important info
          FUNCTION_ARN=$(jq -r '.FunctionArn' lambda-response.json)
          IMAGE_URI=$(jq -r '.ImageConfigResponse.ImageUri' lambda-response.json)
          LAST_MODIFIED=$(jq -r '.LastModified' lambda-response.json)

          echo "function-arn=$FUNCTION_ARN" >> $GITHUB_OUTPUT
          echo "image-uri=$IMAGE_URI" >> $GITHUB_OUTPUT
          echo "last-modified=$LAST_MODIFIED" >> $GITHUB_OUTPUT

      - name: Wait for function code update to complete
        run: |
          echo "‚è≥ Waiting for Lambda function update to complete..."
          aws lambda wait function-updated \
            --function-name $LAMBDA_FUNCTION_NAME \
            --region ${{ env.AWS_REGION }}
          echo "‚úÖ Lambda function code update completed successfully"

      - name: Ensure Lambda image handler configuration
        run: |
          echo "üîß Ensuring Lambda image handler command is src.main.lambda_handler"

          # Retry logic with exponential backoff for configuration update
          MAX_RETRIES=5
          RETRY_COUNT=0
          RETRY_DELAY=5

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if aws lambda update-function-configuration \
              --function-name $LAMBDA_FUNCTION_NAME \
              --image-config '{"Command":["src.main.lambda_handler"]}' \
              --region ${{ env.AWS_REGION }} \
              --no-cli-pager; then
              echo "‚úÖ Lambda configuration updated successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "‚ö†Ô∏è Configuration update failed (attempt $RETRY_COUNT/$MAX_RETRIES)"
                echo "Waiting ${RETRY_DELAY}s before retry..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))  # Exponential backoff
              else
                echo "‚ùå Configuration update failed after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

      - name: Wait for Lambda update to complete
        run: |
          echo "‚è≥ Waiting for Lambda update to complete..."
          for i in {1..30}; do
            STATE=$(aws lambda get-function \
              --function-name $LAMBDA_FUNCTION_NAME \
              --region ${{ env.AWS_REGION }} \
              --query 'Configuration.State' --output text)
            
            if [ "$STATE" = "Active" ]; then
              echo "‚úÖ Lambda is Active"
              break
            fi
            
            echo "State: $STATE (attempt $i/30)"
            sleep 5
          done

      - name: Test Lambda invocation (async + log verification)
        id: lambda-test
        env:
          LOG_GROUP: /aws/lambda/${{ env.LAMBDA_FUNCTION_NAME }}
        run: |
          echo "üß™ Smoke test: async invoke + CloudWatch verification"

          # 1) Permission and existence check without execution
          echo "üîé DryRun to validate permissions and function exists"
          aws lambda invoke \
            --function-name "$LAMBDA_FUNCTION_NAME" \
            --region "${{ env.AWS_REGION }}" \
            --invocation-type DryRun \
            /dev/null 1>/dev/null

          # 2) Async invoke (don't hold HTTP connection open)
          echo "üöÄ Async invoking function (InvocationType=Event)"
          aws lambda invoke \
            --function-name "$LAMBDA_FUNCTION_NAME" \
            --region "${{ env.AWS_REGION }}" \
            --invocation-type Event \
            --payload '{}' \
            /dev/null 1>/dev/null

          # 3) Poll CloudWatch logs for evidence that the function started
          echo "üìã Waiting for CloudWatch logs to confirm start..."
          START_EPOCH_MS=$(( ( $(date +%s) - 300 ) * 1000 ))  # last 5 minutes
          MAX_WAIT=120   # seconds
          SLEEP=5        # seconds
          ELAPSED=0

          FOUND=0
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            set +e
            EVENTS=$(aws logs filter-log-events \
              --log-group-name "$LOG_GROUP" \
              --start-time "$START_EPOCH_MS" \
              --limit 50 \
              --region "${{ env.AWS_REGION }}" \
              --query 'events[].message' \
              --output text 2>/dev/null)
            STATUS=$?
            set -e

            if [ $STATUS -eq 0 ] && echo "$EVENTS" | grep -Eiq "(^| )START RequestId|Starting Naver SMS automation Lambda handler"; then
              FOUND=1
              break
            fi

            echo "‚è≥ No start logs yet... waiting (${ELAPSED}s/${MAX_WAIT}s)"
            sleep $SLEEP
            ELAPSED=$((ELAPSED + SLEEP))
          done

          if [ $FOUND -ne 1 ]; then
            echo "‚ùå Did not observe Lambda start logs within ${MAX_WAIT}s"
            echo "Common root causes:"
            echo "- Heavy cold start (Chrome init) exceeding startup expectations"
            echo "- Wrong handler path or image command"
            echo "- VPC ENI cold start delays or missing network egress"
            echo "- Execution role issues causing immediate init failure"
            exit 1
          fi

          echo "‚úÖ Lambda started successfully (confirmed via CloudWatch logs)"

      - name: Check Lambda CloudWatch logs
        if: always()
        run: |
          echo "üìã Fetching latest CloudWatch logs..."
          
          LOG_GROUP="/aws/lambda/$LAMBDA_FUNCTION_NAME"
          
          # Get latest log stream
          LATEST_STREAM=$(aws logs describe-log-streams \
            --log-group-name "$LOG_GROUP" \
            --order-by LastEventTime \
            --descending \
            --max-items 1 \
            --region ${{ env.AWS_REGION }} \
            --query 'logStreams[0].logStreamName' \
            --output text)
          
          if [ "$LATEST_STREAM" != "None" ] && [ -n "$LATEST_STREAM" ]; then
            echo "Latest log stream: $LATEST_STREAM"
            if ! aws logs get-log-events \
              --log-group-name "$LOG_GROUP" \
              --log-stream-name "$LATEST_STREAM" \
              --region ${{ env.AWS_REGION }} \
              --limit 50 \
              --query 'events[*].message' \
              --output text; then
              echo "‚ö†Ô∏è Unable to read events from $LATEST_STREAM (stream may be new or empty)."
            fi
          else
            echo "No log streams found yet"
          fi

      - name: Create deployment summary
        run: |
          cat > deployment-summary.txt << EOF
          ============================================
          AWS LAMBDA DEPLOYMENT SUMMARY
          ============================================
          
          Deployment Status: ‚úÖ SUCCESS
          
          Lambda Function:
            Name: $LAMBDA_FUNCTION_NAME
            ARN: ${{ steps.lambda-update.outputs.function-arn }}
            Region: ${{ env.AWS_REGION }}
            Updated: ${{ steps.lambda-update.outputs.last-modified }}
          
          Container Image:
            URI: ${{ needs.build-and-push.outputs.image-uri }}
            Tag: ${{ needs.build-and-push.outputs.image-tag }}
            Registry: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          
          Git Context:
            Commit: ${{ github.sha }}
            Branch: ${{ github.ref }}
            Author: ${{ github.actor }}
          
          ============================================
          EOF
          
          cat deployment-summary.txt

      - name: Upload deployment summary
        uses: actions/upload-artifact@v4
        with:
          name: deployment-summary
          path: deployment-summary.txt
          retention-days: 30

  # ============================================================================
  # DOCUMENTATION UPDATES
  # ============================================================================
  update-docs:
    name: Update Documentation
    runs-on: ubuntu-latest
    needs: deploy-lambda
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    continue-on-error: true  # Don't fail entire workflow if docs update fails
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0  # Fetch full history for commit messages
          persist-credentials: true  # Keep credentials for git push

      - name: Update deployment log
        run: |
          DEPLOYMENT_LOG="docs/ops/DEPLOYMENTS.md"
          TIMESTAMP=$(date -u '+%Y-%m-%d %H:%M:%S UTC')
          COMMIT_SHA=${{ github.sha }}
          COMMIT_SHORT="${COMMIT_SHA:0:7}"

          # Get first line of commit message and sanitize it (remove pipes, limit length)
          COMMIT_MSG=$(git log -1 --pretty=%s "$COMMIT_SHA" | head -c 80 | tr '|' '/')

          # Create file if it doesn't exist
          if [ ! -f "$DEPLOYMENT_LOG" ]; then
            mkdir -p $(dirname "$DEPLOYMENT_LOG")
            cat > "$DEPLOYMENT_LOG" << 'EOF'
          # Deployment History

          Automated deployments to AWS Lambda from main branch.

          | Date | Commit | Message | Status |
          |------|--------|---------|--------|
          EOF
          fi

          # Add new entry using a temporary file (safer than sed with special chars)
          {
            head -n 5 "$DEPLOYMENT_LOG"
            echo "| $TIMESTAMP | \`$COMMIT_SHORT\` | $COMMIT_MSG | PASS |"
            tail -n +6 "$DEPLOYMENT_LOG"
          } > "${DEPLOYMENT_LOG}.tmp"

          mv "${DEPLOYMENT_LOG}.tmp" "$DEPLOYMENT_LOG"

      - name: Commit documentation updates
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          if [ -n "$(git status -s)" ]; then
            git add docs/ops/DEPLOYMENTS.md
            git commit -m "docs: update deployment history [skip ci]"
            
            # Try to push with error handling
            if git push; then
              echo "Documentation updated successfully"
            else
              echo "WARNING: Failed to push documentation updates"
              echo "This is likely due to repository permissions."
              echo "Please check: Settings -> Actions -> General -> Workflow permissions"
              echo "Ensure 'Read and write permissions' is enabled."
              exit 0  # Don't fail the job, just warn
            fi
          else
            echo "No documentation changes to commit"
          fi

  # ============================================================================
  # NOTIFICATIONS
  # ============================================================================
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [test, build-and-push, deploy-lambda]
    if: always()
    steps:
      - name: Determine deployment status
        id: status
        run: |
          if [ "${{ needs.deploy-lambda.result }}" = "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "emoji=‚úÖ" >> $GITHUB_OUTPUT
            echo "color=good" >> $GITHUB_OUTPUT
            echo "message=Deployment to AWS Lambda successful" >> $GITHUB_OUTPUT
          elif [ "${{ needs.deploy-lambda.result }}" = "skipped" ]; then
            echo "status=skipped" >> $GITHUB_OUTPUT
            echo "emoji=‚è≠Ô∏è" >> $GITHUB_OUTPUT
            echo "color=warning" >> $GITHUB_OUTPUT
            echo "message=Deployment skipped (PR or non-main branch)" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "emoji=‚ùå" >> $GITHUB_OUTPUT
            echo "color=danger" >> $GITHUB_OUTPUT
            echo "message=Deployment to AWS Lambda failed" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack Notification
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "attachments": [
                {
                  "color": "${{ steps.status.outputs.color }}",
                  "title": "${{ steps.status.outputs.emoji }} ${{ steps.status.outputs.message }}",
                  "title_link": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
                  "fields": [
                    {
                      "title": "Workflow",
                      "value": "${{ github.workflow }}",
                      "short": true
                    },
                    {
                      "title": "Status",
                      "value": "Test: ${{ needs.test.result }} | Build: ${{ needs.build-and-push.result }} | Deploy: ${{ needs.deploy-lambda.result }}",
                      "short": false
                    },
                    {
                      "title": "Branch",
                      "value": "${{ github.ref_name }}",
                      "short": true
                    },
                    {
                      "title": "Author",
                      "value": "${{ github.actor }}",
                      "short": true
                    },
                    {
                      "title": "Commit",
                      "value": "<${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }} | ${{ github.sha }}>",
                      "short": true
                    },
                    {
                      "title": "Repository",
                      "value": "${{ github.repository }}",
                      "short": true
                    }
                  ],
                  "footer": "GitHub Actions",
                  "ts": "$(date +%s)"
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

      - name: Create deployment notification
        run: |
          cat > notification.txt << EOF
          ${{ steps.status.outputs.emoji }} ${{ steps.status.outputs.message }}
          
          Workflow: ${{ github.workflow }}
          Commit: ${{ github.sha }}
          Branch: ${{ github.ref_name }}
          Author: ${{ github.actor }}
          
          Repository: ${{ github.repository }}
          Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          EOF
          
          cat notification.txt

      - name: Print deployment details
        run: |
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üìä GITHUB ACTIONS DEPLOYMENT SUMMARY"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo ""
          echo "Test Phase: ${{ needs.test.result }}"
          echo "Build Phase: ${{ needs.build-and-push.result }}"
          echo "Deploy Phase: ${{ needs.deploy-lambda.result }}"
          echo ""
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
